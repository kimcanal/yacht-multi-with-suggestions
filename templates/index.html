<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ² Yacht</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            background: linear-gradient(135deg, #0f0f1e 0%, #1a1a3e 100%);
            color: #fff; 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            min-height: 100vh;
            padding: 20px;
        }
        .game-wrapper {
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            gap: 40px;
            flex-wrap: wrap;
            align-items: flex-start;
        }
        .main-area {
            flex: 1;
            min-width: 400px;
        }
        .title {
            font-size: 3em;
            font-weight: 700;
            margin-bottom: 30px;
            text-shadow: 0 0 30px rgba(0, 255, 200, 0.3);
            color: #00ffcc;
        }
        .dice-area {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 20px;
            padding: 40px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            margin-bottom: 30px;
        }
        .dice-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            justify-content: center;
            margin-bottom: 30px;
        }
        .dice-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }
        .die-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }
        .keep-btn {
            padding: 6px 12px;
            font-size: 12px;
            font-weight: bold;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.05);
            color: #fff;
            cursor: pointer;
            transition: all 0.2s ease;
            min-width: 80px;
            text-align: center;
        }
        .keep-btn:hover {
            border-color: rgba(0, 255, 200, 0.6);
            background: rgba(0, 255, 200, 0.1);
        }
        .keep-btn.active-keep {
            border-color: #00ff00;
            background: rgba(0, 255, 0, 0.2);
            color: #00ff00;
            font-weight: bold;
        }
        .keep-btn.active-reroll {
            border-color: #ff4444;
            background: rgba(255, 68, 68, 0.2);
            color: #ff4444;
            font-weight: bold;
        }
        .die-container {
            width: 100px;
            height: 100px;
            position: relative;
            perspective: 1000px;
            transition: transform 0.3s ease;
        }
        .die-container.locked {
            transform: translateY(-15px);
        }
        .die {
            width: 100%;
            height: 100%;
            position: absolute;
            transform-style: preserve-3d;
            transition: transform 0.8s cubic-bezier(0.2, 0.8, 0.2, 1);
        }
        .die-face {
            position: absolute;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(255,255,255,0.98), rgba(240,240,240,0.9));
            border: 2px solid rgba(200,200,200,0.5);
            border-radius: 16px;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            padding: 8px;
            backface-visibility: hidden;
            box-shadow: inset 0 0 15px rgba(0,0,0,0.05);
        }
        .die-face .dot {
            margin: auto;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.5);
        }
        
        /* 3D Face Transforms */
        .face-1 { transform: rotateY(0deg) translateZ(50px); }
        .face-6 { transform: rotateY(180deg) translateZ(50px); }
        .face-2 { transform: rotateX(90deg) translateZ(50px); }
        .face-5 { transform: rotateX(-90deg) translateZ(50px); }
        .face-3 { transform: rotateY(90deg) translateZ(50px); }
        .face-4 { transform: rotateY(-90deg) translateZ(50px); }

        .die.rolling {
            animation: roll3d 1.5s linear infinite;
        }
        @keyframes roll3d {
            0% { transform: rotateX(0) rotateY(0) rotateZ(0); }
            100% { transform: rotateX(720deg) rotateY(360deg) rotateZ(360deg); }
        }
        .dot {
            width: 18px;
            height: 18px;
            background: #333;
            border-radius: 50%;
            transition: all 0.2s;
        }
        .dot.hidden {
            opacity: 0;
        }
        
        .lock-label {
            font-size: 11px;
            font-weight: bold;
            color: #999;
            min-height: 14px;
        }
        .controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-bottom: 30px;
        }
        .btn {
            padding: 12px 30px;
            font-size: 16px;
            font-weight: 600;
            border: none;
            border-radius: 30px;
            cursor: pointer;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
            transition: all 0.3s ease;
        }
        .btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 25px rgba(102, 126, 234, 0.6);
        }
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .btn-reset {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }
        .info-bar {
            background: rgba(0, 255, 204, 0.1);
            border: 2px solid #00ffcc;
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            font-size: 1.2em;
            color: #00ffcc;
            font-weight: bold;
        }
        .rolls-remaining {
            font-size: 1.5em;
            margin-bottom: 15px;
        }
        .scorecard-area {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 20px;
            padding: 30px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            min-width: 350px;
        }
        .scorecard-title {
            font-size: 1.8em;
            font-weight: 700;
            margin-bottom: 25px;
            color: #00ffcc;
            text-align: center;
        }
        .score-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 14px 16px;
            margin: 8px 0;
            font-size: 1.05em;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            border-left: 4px solid transparent;
            position: relative;
        }
        .score-item:hover:not(.filled):not(.bonus) {
            background: rgba(102, 126, 234, 0.3);
            border-left-color: #667eea;
            transform: translateX(5px);
        }
        .score-item.filled {
            background: rgba(0, 255, 204, 0.15);
            cursor: default;
            border-left-color: #00ffcc;
        }
        .score-item.bonus {
            background: rgba(255, 215, 0, 0.15);
            border-left-color: #ffd700;
            font-weight: bold;
            cursor: default;
        }
        .score-name {
            font-weight: 500;
            font-size: 1.05em;
            flex: 1;
        }
        .score-val {
            font-weight: bold;
            color: #ffd700;
            font-size: 1.1em;
            min-width: 60px;
            text-align: right;
        }
        .score-preview {
            font-size: 0.85em;
            color: #00ffcc;
            margin-left: 10px;
            opacity: 0.8;
        }
        /* ì»¤ìŠ¤í…€ íˆ´íŒ: ì£¼ì‚¬ìœ„ëŠ” í¬ê²Œ, ì„¤ëª…ì€ ê°€ë…ì„± ìˆê²Œ */
        .custom-tip {
            position: absolute;
            left: 0;
            bottom: 100%;
            width: 100%;
            background: rgba(0, 0, 0, 0.9);
            color: #fff;
            padding: 10px 12px;
            border-radius: 10px;
            box-shadow: 0 6px 18px rgba(0, 0, 0, 0.35);
            z-index: 20;
            pointer-events: none;
        }
        .custom-tip::before {
            content: '';
            position: absolute;
            left: 20px;
            bottom: -10px;
            border: 8px solid transparent;
            border-top-color: rgba(0, 0, 0, 0.9);
        }
        .custom-tip .tip-dice {
            font-size: 1.4em;
            line-height: 1.2;
            margin-bottom: 6px;
        }
        .custom-tip .tip-desc {
            font-size: 1.05em;
            line-height: 1.5;
            white-space: pre-line;
        }
        .total-score {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 2px solid rgba(255, 255, 255, 0.2);
            display: flex;
            justify-content: space-between;
            font-size: 1.3em;
            font-weight: bold;
            color: #ffd700;
        }
        .ai-breakdown {
            margin-top: 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 12px;
            font-size: 0.9em;
            text-align: left;
        }
        .breakdown-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            gap: 10px;
        }
        .breakdown-item:last-child { border-bottom: none; }
        .breakdown-val { color: #00ffcc; font-weight: bold; }
        .spinner {
            display: inline-block;
            width: 14px;
            height: 14px;
            border: 2px solid rgba(0, 255, 204, 0.3);
            border-radius: 50%;
            border-top-color: #00ffcc;
            animation: spin 1s ease-in-out infinite;
            margin-left: 10px;
            vertical-align: middle;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        .toast-overlay {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.9);
            background: rgba(20, 20, 40, 0.95);
            color: #fff;
            padding: 30px 50px;
            border-radius: 20px;
            font-size: 2em;
            font-weight: 800;
            text-align: center;
            z-index: 2000;
            pointer-events: none;
            opacity: 0;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            border: 2px solid #00ffcc;
            box-shadow: 0 0 50px rgba(0, 255, 204, 0.4);
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .toast-overlay.show {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
        }
        .toast-cat { font-size: 0.6em; color: #aaa; text-transform: uppercase; letter-spacing: 2px; }
        .toast-score { font-size: 1.5em; color: #ffd700; text-shadow: 0 0 20px rgba(255, 215, 0, 0.5); }
    </style>
</head>
<body>
    <div class="game-wrapper">
        <div class="main-area">
            <div class="title">ğŸ² YACHT <span id="room-label" style="font-size:0.4em; color:#fff; opacity:0.8; margin-left:12px;"></span></div>
            
            <div class="dice-area">
                <div class="dice-grid" id="dice-grid">
                    <!-- Dice generated by JS -->
                </div>
                
                <div class="info-bar">
                    <div class="rolls-remaining">ë‚¨ì€ Roll: <span id="rolls-left">3</span>/3</div>
                    <div id="game-status" style="margin-top: 10px; color: #00ffcc; font-size: 0.9em; text-align: center; min-height: 24px;"></div>
                    <div id="ai-breakdown" class="ai-breakdown"></div>
                    <div id="ai-info-tip" style="margin-top: 8px; padding: 8px 12px; background: rgba(0, 255, 204, 0.1); border-left: 3px solid #00ffcc; border-radius: 5px; font-size: 0.75em; color: #aaa; line-height: 1.4; display: none;">
                        ğŸ’¡ AI ì¶”ì²œ: ê° ì£¼ì‚¬ìœ„ë¥¼ keepí–ˆì„ ë•Œ ë‚¨ì€ ì£¼ì‚¬ìœ„ë“¤ì„ ë‹¤ì‹œ êµ´ë ¸ì„ ë•Œ<br>keepí•œ ê²ƒê³¼ ê°™ì€ ìˆ«ìê°€ ë‚˜ì˜¬ í™•ë¥ ì„ ê³„ì‚°í•˜ì—¬<br>ê°€ì¥ ìœ ë¦¬í•œ ì¡°í•©ì„ ì¶”ì²œí•©ë‹ˆë‹¤.
                    </div>
                </div>
                
                <div class="controls">
                    <button class="btn" onclick="rollDice()" id="roll-btn">ğŸ² ROLL</button>
                    <button class="btn btn-reset" onclick="resetGame()" id="new-game-btn">ğŸ”„ NEW GAME</button>
                    <button class="btn" style="background:linear-gradient(135deg, #ff6b6b 0%, #c92a2a 100%); box-shadow:0 4px 15px rgba(255,107,107,0.4);" onclick="leaveRoom()">ğŸšº ë‚˜ê°€ê¸°</button>
                </div>
                
                <div class="controls" style="margin-top:10px; display:none;" id="multiplayer-controls">
                    <button class="btn" style="background:linear-gradient(135deg, #4ecdc4 0%, #44a08d 100%); box-shadow:0 4px 15px rgba(78,205,196,0.4); display:none;" id="pass-turn-btn" onclick="passTurn()">ğŸ” ì„ ê³µê¶Œ ë„˜ê¸°ê¸°</button>
                </div>
            </div>
        </div>

        <div class="scorecard-area">
            <div id="scorecard"></div>
        </div>
    </div>

    <div id="score-toast" class="toast-overlay"></div>
    <script>
        const GameState = (() => {
            let state = {
                dice: [1,1,1,1,1],
                kept: [0,0,0,0,0],
                rollsLeft: 3,
                myCard: Array(12).fill(null),
                oppCard: Array(12).fill(null),
                gameOver: false,
                aiRec: null
            };
            
            return {
                getDice: () => [...state.dice],
                setDice: (value) => { state.dice = [...value]; },
                getKept: () => [...state.kept],
                setKept: (value) => { state.kept = [...value]; },
                getRollsLeft: () => state.rollsLeft,
                setRollsLeft: (value) => { state.rollsLeft = value; },
                getMyCard: () => [...state.myCard],
                setMyCard: (value) => { state.myCard = [...value]; },
                getOppCard: () => [...state.oppCard],
                setOppCard: (value) => { state.oppCard = [...value]; },
                isGameOver: () => state.gameOver,
                setGameOver: (value) => { state.gameOver = value; },
                getAiRec: () => state.aiRec,
                setAiRec: (value) => { state.aiRec = value; },
                getState: () => ({ ...state }),
                setState: (newState) => { state = { ...state, ...newState }; }
            };
        })();

        const CATS = ['Ones','Twos','Threes','Fours','Fives','Sixes','Choice','4 of a Kind','Full House','Small Straight','Large Straight','Yacht'];
        
        // ì¹´í…Œê³ ë¦¬ ì„¤ëª…/ì˜ˆ) ì˜ˆì‹œ (íˆ´íŒìš©)
        const CAT_DESC = {
            'Ones': '1ì´ ë‚˜ì˜¨ ì£¼ì‚¬ìœ„ ëˆˆì˜ ì´í•© (ìµœëŒ€ 5ì )',
            'Twos': '2ê°€ ë‚˜ì˜¨ ì£¼ì‚¬ìœ„ ëˆˆì˜ ì´í•© (ìµœëŒ€ 10ì )',
            'Threes': '3ì´ ë‚˜ì˜¨ ì£¼ì‚¬ìœ„ ëˆˆì˜ ì´í•© (ìµœëŒ€ 15ì )',
            'Fours': '4ê°€ ë‚˜ì˜¨ ì£¼ì‚¬ìœ„ ëˆˆì˜ ì´í•© (ìµœëŒ€ 20ì )',
            'Fives': '5ê°€ ë‚˜ì˜¨ ì£¼ì‚¬ìœ„ ëˆˆì˜ ì´í•© (ìµœëŒ€ 25ì )',
            'Sixes': '6ì´ ë‚˜ì˜¨ ì£¼ì‚¬ìœ„ ëˆˆì˜ ì´í•© (ìµœëŒ€ 30ì )',
            'Choice': 'ì£¼ì‚¬ìœ„ ëˆˆ 5ê°œì˜ ì´í•© (ìµœëŒ€ 30ì )',
            '4 of a Kind': 'ë™ì¼í•œ ì£¼ì‚¬ìœ„ ëˆˆì´ 4ê°œ ì´ìƒì¼ ë•Œ, ì£¼ì‚¬ìœ„ ëˆˆ 5ê°œì˜ ì´í•© (ìµœëŒ€ 30ì )',
            'Full House': 'ì£¼ì‚¬ìœ„ë¥¼ 3ê°œ, 2ê°œë¡œ ë¬¶ì—ˆì„ ë•Œ ê°ê°ì˜ ë¬¶ìŒ ì•ˆì—ì„œ ì£¼ì‚¬ìœ„ ëˆˆì´ ì„œë¡œ ë™ì¼í•  ë•Œ, ì£¼ì‚¬ìœ„ ëˆˆ 5ê°œì˜ ì´í•©. ìµœëŒ€ 30ì .',
            'Single Straight': 'ì—°ì†ëœ ì£¼ì‚¬ìœ„ ëˆˆì´ 4ê°œ ì´ìƒì¼ ë•Œ, ê³ ì • 15ì  (ì˜ˆ: 1-2-3-4, 2-3-4-5, 3-4-5-6)',
            'Large Straight': 'ì—°ì†ëœ ì£¼ì‚¬ìœ„ ëˆˆì´ 5ê°œì¼ ë•Œ, ê³ ì • 30ì  (1-2-3-4-5 ë˜ëŠ” 2-3-4-5-6)',
            'Yacht': 'ë™ì¼í•œ ì£¼ì‚¬ìœ„ ëˆˆì´ 5ê°œì¼ ë•Œ, ê³ ì • 50ì '
        };
        const CAT_DICE = {
            'Ones': 'âš€âš€âš€âš„âš… = 3ì ',
            'Twos': 'âšâšâšâš„âš… = 6ì ',
            'Threes': 'âš‚âš‚âš‚âš„âš… = 9ì ',
            'Fours': 'âš€âšâšƒâšƒâšƒ = 12ì ',
            'Fives': 'âš€âšâš„âš„âš„ = 15ì ',
            'Sixes': 'âš€âšâš…âš…âš… = 18ì ',
            'Choice': 'âš‚âšƒâš„âš…âš… = 24ì ',
            '4 of a Kind': 'âš„âš…âš…âš…âš… = 29ì ',
            'Full House': 'âš„âš„âš…âš…âš… = 28ì ',
            'Single Straight': 'âš€âšâš‚âšƒâš„ = 15ì ',
            'Large Straight': 'âšâš‚âšƒâš„âš… = 30ì ',
            'Yacht': 'âš€âš€âš€âš€âš€ = 50ì '
        };
        const params = new URLSearchParams(window.location.search);
        const storedMode = localStorage.getItem('yacht_mode');
        let roomCode = params.get('room') || localStorage.getItem('yacht_room') || '';
        // ê¸°ë³¸ê°’ì€ ì‹±ê¸€ ëª¨ë“œë¡œ ë³´ê³ , ë©€í‹° ëª¨ë“œë¡œ ëª…ì‹œí•œ ê²½ìš°ì—ë§Œ roomCode ì‚¬ìš©
        if (storedMode !== 'multi') {
            roomCode = '';
            localStorage.removeItem('yacht_room');
        }
        if (roomCode) {
            localStorage.setItem('yacht_room', roomCode);
        }
        const isMultiplayer = storedMode === 'multi' && !!roomCode;
        const username = localStorage.getItem('yacht_username') || '';
        if (isMultiplayer && !username) {
            alert('ë‹‰ë„¤ì„ ì •ë³´ê°€ ì—†ìŠµë‹ˆë‹¤. ë¡œë¹„ì—ì„œ ë‹¤ì‹œ ì…ì¥í•´ì£¼ì„¸ìš”.');
            window.location.href = '/';
        }
        let roomVersion = 0;
        let syncTimer = null;
        let isApplyingRemote = false;
        let roomPlayers = [];
        let opponentName = '';
        let turnOwner = null;
        let isRolling = false;
        let gameOverToastShown = false;
        let connectionLostHandled = false;
        let syncFailures = 0;

        // í¸ì˜ì„± ë³€ìˆ˜ (ì½ê¸° ì „ìš©)
        let dice, kept, rollsLeft, myCard, oppCard, gameOver, aiRec;
        function updateLocalVars() {
            const state = GameState.getState();
            dice = state.dice;
            kept = state.kept;
            rollsLeft = state.rollsLeft;
            myCard = state.myCard;
            oppCard = state.oppCard;
            gameOver = state.gameOver;
            aiRec = state.aiRec;
        }
        updateLocalVars();

        function playTurnToastSound() {
            // ê²½ì¾Œí•œ 2ìŒ ì—…ì›Œë“œ ì°¨ì„ (í„´ ë„˜ê¹€/ë°›ìŒ ê³µìš©)
            try {
                const ctx = new (window.AudioContext || window.webkitAudioContext)();
                const now = ctx.currentTime;
                const env = ctx.createGain();
                env.gain.setValueAtTime(0.14, now);
                env.gain.exponentialRampToValueAtTime(0.001, now + 0.6);

                const osc1 = ctx.createOscillator();
                osc1.type = 'triangle';
                osc1.frequency.setValueAtTime(660, now);
                osc1.frequency.exponentialRampToValueAtTime(990, now + 0.25);

                const osc2 = ctx.createOscillator();
                osc2.type = 'sine';
                osc2.frequency.setValueAtTime(1320, now + 0.05);
                osc2.frequency.exponentialRampToValueAtTime(1760, now + 0.35);

                osc1.connect(env);
                osc2.connect(env);
                env.connect(ctx.destination);

                osc1.start(now);
                osc2.start(now + 0.05);
                osc1.stop(now + 0.6);
                osc2.stop(now + 0.6);
            } catch (e) {
                console.warn('toast sound failed', e);
            }
        }

        function handleConnectionLost(msg = 'ìƒëŒ€ë°©ê³¼ì˜ ì—°ê²°ì´ ëŠì–´ì¡ŒìŠµë‹ˆë‹¤. ë¡œë¹„ë¡œ ì´ë™í•©ë‹ˆë‹¤.') {
            if (connectionLostHandled) return;
            connectionLostHandled = true;
            localStorage.removeItem('yacht_room');
            alert(msg);
            window.location.replace('/');
        }

        // ë„¤íŠ¸ì›Œí¬ ì˜¤í”„ë¼ì¸ ì¦‰ì‹œ ì•ˆë‚´
        window.addEventListener('offline', () => {
            handleConnectionLost('ë„¤íŠ¸ì›Œí¬ ì—°ê²°ì´ ëŠì–´ì¡ŒìŠµë‹ˆë‹¤. ë¡œë¹„ë¡œ ì´ë™í•©ë‹ˆë‹¤.');
        });

        function showGameOverToast(myTotal, oppTotal) {
            if (gameOverToastShown) return;
            const toast = document.getElementById('score-toast');
            let title = 'ğŸ‰ ê²Œì„ ì¢…ë£Œ';
            let detail = `ìµœì¢… ì ìˆ˜: ${myTotal}`;
            if (isMultiplayer) {
                if (myTotal > oppTotal) title = 'ğŸ† ìŠ¹ë¦¬!';
                else if (myTotal < oppTotal) title = 'ğŸ˜¥ íŒ¨ë°°';
                else title = 'ğŸ¤ ë¬´ìŠ¹ë¶€';
                detail = `ë‚˜ ${myTotal} : ìƒëŒ€ ${oppTotal}`;
            }
            toast.innerHTML = `<div class="toast-cat">${title}</div><div class="toast-score">${detail}</div>`;
            toast.classList.add('show');
            playTurnToastSound();
            gameOverToastShown = true;
            setTimeout(() => toast.classList.remove('show'), 2800);
        }

        const isMyTurn = () => {
            if (!isMultiplayer) return true;
            if (!turnOwner) return false;  // í„´ ì†Œìœ ìê°€ ì„¤ì •ë  ë•Œê¹Œì§€ ëŒ€ê¸°
            return turnOwner === username;
        };

        function refreshTurnUI() {
            const statusEl = document.getElementById('game-status');
            if (!statusEl || GameState.isGameOver()) return;
            if (isMultiplayer && (!opponentName || roomPlayers.length < 2)) {
                statusEl.innerText = 'â³ ìƒëŒ€ë°© ì…ì¥ ëŒ€ê¸° ì¤‘...';
            } else if (isMultiplayer && !isMyTurn()) {
                statusEl.innerText = 'â¸ï¸ ìƒëŒ€ í„´ì…ë‹ˆë‹¤';
            } else {
                statusEl.innerText = '';
            }

            // ì„ ê³µê¶Œ ë„˜ê¸°ê¸° ë²„íŠ¼ í‘œì‹œ ì¡°ê±´: ë©€í‹°í”Œë ˆì´ì–´, ë‚´ í„´, ì•„ì§ ì ìˆ˜ ê¸°ë¡ ì „, êµ´ë¦¼ ì „(rollsLeft===3)
            const passBtn = document.getElementById('pass-turn-btn');
            if (passBtn) {
                const myEmpty = GameState.getMyCard().every(v => v === null);
                const oppEmpty = GameState.getOppCard().every(v => v === null);
                const canPass = isMultiplayer && isMyTurn() && rollsLeft === 3 && myEmpty && oppEmpty && !gameOver;
                passBtn.style.display = canPass ? 'inline-flex' : 'none';
            }

            updateDice();
        }

        function renderDice() {
            const dotMap = {
                1: [5], 2: [1,9], 3: [1,5,9], 4: [1,3,7,9], 5: [1,3,5,7,9], 6: [1,3,4,6,7,9]
            };

            const g = document.getElementById('dice-grid');
            g.innerHTML = CATS.slice(0,5).map((_, i) => `
                <div class="dice-item" id="dice-item-${i}">
                    <div class="die-container" id="die-container-${i}">
                        <div class="die" id="die-${i}">
                            ${[1,2,3,4,5,6].map(f => `
                                <div class="die-face face-${f}">
                                    ${[1,2,3,4,5,6,7,8,9].map(d => 
                                        `<div class="dot ${dotMap[f].includes(d) ? '' : 'hidden'}"></div>`
                                    ).join('')}
                                </div>
                            `).join('')}
                        </div>
                    </div>
                    <button class="keep-btn" id="keep-${i}" onclick="toggleLock(${i})">
                        <span id="keep-text-${i}">KEEP</span>
                    </button>
                    <div class="lock-label" id="lock-${i}"></div>
                </div>
            `).join('');
            
            // AI ì •ë³´ íŒ í‘œì‹œ (ì‹±ê¸€ ëª¨ë“œë§Œ)
            const aiInfoTip = document.getElementById('ai-info-tip');
            if (aiInfoTip) {
                aiInfoTip.style.display = isMultiplayer ? 'none' : 'block';
            }
            
            updateDice();
        }

        function updateDice() {
            const transforms = {
                1: 'rotateX(0deg) rotateY(0deg)',
                6: 'rotateX(180deg) rotateY(0deg)',
                2: 'rotateX(-90deg) rotateY(0deg)',
                5: 'rotateX(90deg) rotateY(0deg)',
                3: 'rotateY(-90deg) rotateX(0deg)',
                4: 'rotateY(90deg) rotateX(0deg)'
            };
            
            for (let i = 0; i < 5; i++) {
                const d = document.getElementById(`die-${i}`);
                const c = document.getElementById(`die-container-${i}`);
                if (!d) continue;
                
                // í„´ ì‹œì‘(3íšŒ ë‚¨ìŒ) ì‹œì—ëŠ” ê³„ì† êµ´ëŸ¬ê°€ê²Œ ì—°ì¶œ, ê·¸ ì™¸ì—ëŠ” ë©ˆì¶¤
                if (rollsLeft === 3 && !gameOver) {
                    d.classList.add('rolling');
                } else {
                    d.classList.remove('rolling');
                }

                // locked í´ë˜ìŠ¤ í† ê¸€
                if (GameState.getKept()[i]) {
                    c.classList.add('locked');
                    d.querySelectorAll('.die-face').forEach(f => f.style.borderColor = '#00ffcc');
                } else {
                    c.classList.remove('locked');
                    d.querySelectorAll('.die-face').forEach(f => f.style.borderColor = 'rgba(200,200,200,0.5)');
                }
                
                const val = GameState.getDice()[i] || 1; // ì•ˆì „ì¥ì¹˜
                d.style.transform = transforms[val];
                
                // Keep ë²„íŠ¼ ì—…ë°ì´íŠ¸
                const keepBtn = document.getElementById(`keep-${i}`);
                const keepText = document.getElementById(`keep-text-${i}`);
                if (keepBtn && keepText) {
                    keepBtn.className = 'keep-btn';
                    
                    // 1. ë²„íŠ¼ í™œì„±í™” ìƒíƒœ (ë£° ì ìš©)
                    if (rollsLeft >= 3 || rollsLeft === 0 || gameOver || isRolling || !isMyTurn()) {
                        keepBtn.disabled = true;
                        keepBtn.style.opacity = '0.5';
                        keepBtn.style.cursor = 'not-allowed';
                    } else {
                        keepBtn.disabled = false;
                        keepBtn.style.opacity = '1';
                        keepBtn.style.cursor = 'pointer';
                    }
                    
                    // 2. ì‚¬ìš©ì ì„ íƒ ìƒíƒœ ë°˜ì˜ (ìš°ì„ ìˆœìœ„ ë†’ìŒ)
                    if (kept[i]) {
                        keepBtn.classList.add('active-keep'); // ë…¹ìƒ‰ ìŠ¤íƒ€ì¼
                        keepBtn.style.borderColor = '#00ff00';
                    } else {
                        keepBtn.style.borderColor = 'rgba(255, 255, 255, 0.3)';
                    }

                    // 3. AI ì¶”ì²œ ì •ë³´ í‘œì‹œ (ë³´ì¡° ì •ë³´)
                    let aiInfo = '';
                    keepBtn.style.boxShadow = 'none'; // ì´ˆê¸°í™”

                    if (aiRec?.dice_recommendations) {
                        const r = aiRec.dice_recommendations[i];
                        if (r) {
                            // ì¶”ì²œ(Keep)ì¸ë° ë‚´ê°€ ì„ íƒ ì•ˆ í–ˆìœ¼ë©´ ê°•ì¡°
                            if (r.action === 'keep' && !kept[i]) {
                                keepBtn.style.borderColor = '#00ffcc'; // ì¶”ì²œ: Keep
                                keepBtn.style.boxShadow = '0 0 10px rgba(0, 255, 204, 0.8)'; // ë„¤ì˜¨ íš¨ê³¼
                            }
                            aiInfo = '';
                        }
                    }
                    
                    // í…ìŠ¤íŠ¸ ì„¤ì •
                    keepText.innerHTML = (kept[i] ? 'âœ“ KEEP' : 'KEEP') + aiInfo;
                }
                
                const lbl = document.getElementById(`lock-${i}`);
                if (lbl) {
                    lbl.innerText = '';
                }
            }
            document.getElementById('rolls-left').innerText = GameState.getRollsLeft();
            const waitingForOpponent = isMultiplayer && (!opponentName || roomPlayers.length < 2);
            document.getElementById('roll-btn').disabled = GameState.getRollsLeft() <= 0 || GameState.isGameOver() || isRolling || !isMyTurn() || waitingForOpponent;
            
            // ì„ ê³µê¶Œ ë„˜ê¸°ê¸° ë²„íŠ¼ í‘œì‹œ ì¡°ê±´: ê²Œì„ ì‹œì‘ ì „ + ì²« êµ´ë¦¼ ì´ì „(rollsLeft=3) + ë‚´ í„´ + ìƒëŒ€ ì…ì¥ ì™„ë£Œ
            const passTurnBtn = document.getElementById('pass-turn-btn');
            if (passTurnBtn && isMultiplayer) {
                const isGameStarted = GameState.getMyCard().some(v => v !== null) || GameState.getOppCard().some(v => v !== null);
                const canPass = !isGameStarted && GameState.getRollsLeft() === 3 && isMyTurn() && opponentName && roomPlayers.length >= 2;
                passTurnBtn.style.display = canPass ? 'inline-block' : 'none';
            }
        }

        function toggleLock(i) {
            // ë¡¤ì´ ë‚¨ì•˜ì„ ë•Œë§Œ ë½ í† ê¸€ ê°€ëŠ¥ (ì²« ë¡¤ ì „ì—ëŠ” ë¶ˆê°€)
            if (rollsLeft === 3 || gameOver || !isMyTurn()) return;
            // ì ìˆ˜ ì„ íƒ ë‹¨ê³„(rollsLeft=0)ì—ì„œë„ ë½ì„ ê±¸ì–´ë³¼ ìˆ˜ëŠ” ìˆê²Œ í•¨ (ì‹œê°ì  í™•ì¸ìš©)
            
            kept[i] = kept[i] ? 0 : 1;
            // GameStateì—ë„ ë°˜ì˜í•˜ì—¬ UIê°€ ì¦‰ì‹œ ì˜¬ë¼ê°€ë„ë¡
            GameState.setKept(kept);
            updateDice();
            pushState();
        }

        function buildStatePayload() {
            const scores = {};
            scores[username] = myCard;
            if (opponentName) {
                scores[opponentName] = oppCard;
            }
            return {
                username,
                dice,
                kept,
                rolls_left: rollsLeft,
                scores,
                turn: turnOwner || username,
                game_over: gameOver,
                ai_rec: aiRec,  // ìƒëŒ€ë„ AI ì¶”ì²œ ì •ë³´ ìˆ˜ì‹  ê°€ëŠ¥
            };
        }

        async function pushState() {
            if (!isMultiplayer || !roomCode || !username || isApplyingRemote) return;
            try {
                const r = await fetch(`/api/rooms/${roomCode}/sync`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify(buildStatePayload())
                });
                const data = await r.json();
                if (data.state && typeof data.state.version === 'number') {
                    roomVersion = data.state.version;
                }
            } catch (e) {
                console.warn('sync failed', e);
            }
        }

        function applyRemoteState(state) {
            if (!state) return;
            if (typeof state.version === 'number' && state.version <= roomVersion) return;
            isApplyingRemote = true;
            roomVersion = state.version || roomVersion;
            
            // ì´ì „ í„´ ì •ë³´ ì €ì¥ (ì„ ê³µê¶Œ ë³€ê²½ ê°ì§€ìš©)
            const prevTurnOwner = turnOwner;
            
            // ë©€í‹°í”Œë ˆì´: ê° í”Œë ˆì´ì–´ì˜ ì£¼ì‚¬ìœ„ë¥¼ ì„œë²„ì—ì„œ ê°€ì ¸ì™€ í˜„ì¬ í„´ ì£¼ì¸ì˜ ì£¼ì‚¬ìœ„ë§Œ í‘œì‹œ
            if (isMultiplayer) {
                const playerDice = state.player_dice || {};
                const playerKept = state.player_kept || {};
                const playerRollsLeft = state.player_rolls_left || {};

                // ìƒëŒ€ë°© ì´ë¦„ ë³´ì •
                if (!opponentName && state.players && state.players.length > 1) {
                    const opp = state.players.find(p => p !== username);
                    if (opp) opponentName = opp;
                }

                const currentTurnOwner = state.turn;
                const fallbackDice = [1,1,1,1,1];
                const fallbackKept = [0,0,0,0,0];

                // í‘œì‹œí•  ì£¼ì‚¬ìœ„ëŠ” í˜„ì¬ í„´ ì£¼ì¸ì˜ ì €ì¥ëœ ê°’
                let diceToShow = GameState.getDice();
                let keptToShow = GameState.getKept();
                let rollsToShow = GameState.getRollsLeft();
                if (currentTurnOwner && playerDice[currentTurnOwner]) {
                    diceToShow = playerDice[currentTurnOwner] || fallbackDice;
                    keptToShow = playerKept[currentTurnOwner] || fallbackKept;
                    rollsToShow = playerRollsLeft[currentTurnOwner] ?? 3;
                }

                GameState.setDice(diceToShow);
                GameState.setKept(keptToShow);
                GameState.setRollsLeft(rollsToShow);
            } else {
                // ì‹±ê¸€ ëª¨ë“œ: ì„œë²„ ìƒíƒœ ì ìš©
                GameState.setDice(state.dice || GameState.getDice());
                GameState.setKept(state.kept || GameState.getKept());
                GameState.setRollsLeft(state.rolls_left ?? GameState.getRollsLeft());
            }
            GameState.setGameOver(state.game_over ?? GameState.isGameOver());
            
            // players ëª©ë¡ ì—…ë°ì´íŠ¸ (ìƒˆ ìƒëŒ€ ê°ì§€)
            roomPlayers = state.players || roomPlayers;
            console.log('í˜„ì¬ ë°© í”Œë ˆì´ì–´:', roomPlayers, 'ë‚´ ì´ë¦„:', username, 'ìƒëŒ€:', opponentName);
            if (!opponentName && roomPlayers.length > 1) {
                const opp = roomPlayers.find(p => p !== username);
                if (opp) {
                    opponentName = opp;
                    console.log('âœ… ìƒëŒ€ ê°ì§€:', opp);
                }
            }
            
            // í„´ ì •ë³´: ì„œë²„ì˜ í„´ ì •ë³´ë¥¼ í•­ìƒ ë”°ë¦„
            if (state.turn) {
                turnOwner = state.turn;
                console.log('í˜„ì¬ í„´ ì†Œìœ ì:', turnOwner);
            }
            
            // ì ìˆ˜íŒ ë™ê¸°í™”
            const scores = state.scores || {};
            const guessedOpp = Object.keys(scores).find(n => n !== username) || opponentName;
            if (scores[username]) GameState.setMyCard(scores[username]);
            if (guessedOpp && scores[guessedOpp]) {
                opponentName = guessedOpp;
                GameState.setOppCard(scores[guessedOpp]);
            }
            
            // ìƒëŒ€ì˜ AI ì¶”ì²œ ì •ë³´ ìˆ˜ì‹ 
            if (state.ai_rec) {
                GameState.setAiRec(state.ai_rec);
            } else {
                GameState.setAiRec(null);
            }
            
            // ë¡œì»¬ ë³€ìˆ˜ ì—…ë°ì´íŠ¸
            updateLocalVars();
            
            // í„´ ë³€ê²½ ê°ì§€ ë° toast í‘œì‹œ
            // ìƒëŒ€ë°© í„´ì—ì„œ ë‚´ í„´ìœ¼ë¡œ ë°”ë€” ë•Œ í‘œì‹œ (ì´ˆê¸° í„´ ì•„ë‹˜)
            if (prevTurnOwner && prevTurnOwner !== username && turnOwner === username) {
                const toast = document.getElementById('score-toast');
                toast.innerHTML = `<div style="font-size:1.1em; font-weight:bold; color:#00ff00; text-shadow: 0 0 20px rgba(0, 255, 0, 0.8);">âœ¨ ë‹¹ì‹ ì˜ í„´ì…ë‹ˆë‹¤!</div>`;
                toast.classList.add('show');
                playTurnToastSound();
                setTimeout(() => {
                    toast.classList.remove('show');
                }, 2500);
            }
            
            // AI ë¶„ì„ ë¦¬ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸ (ìƒëŒ€ í„´ì¼ ë•Œë„ í‘œì‹œ)
            const bd = document.getElementById('ai-breakdown');
            const aiRec = GameState.getAiRec();
            if (aiRec && aiRec.breakdown && aiRec.breakdown.length > 0) {
                bd.innerHTML = aiRec.breakdown.map(item => {
                    let color = '#ffd700';
                    const barWidth = Math.min(item.prob * 100, 100);
                    return `
                        <div class="breakdown-item">
                            <div style="flex: 1;">
                                <div style="display:flex; align-items:center; gap:8px; margin-bottom:4px;">
                                    <span style="font-size:1.3em; font-weight:bold; color:${color}">â¤</span>
                                    <span style="color:#ccc; font-weight:500">${item.name}</span>
                                </div>
                                <div style="font-size:0.9em; color:#aaa; margin-top:3px; margin-bottom:6px;">${item.keep_str}</div>
                                <div style="background:rgba(0,0,0,0.3); border-radius:6px; height:6px; margin-right:8px;">
                                    <div style="background:${color}; border-radius:6px; height:100%; width:${barWidth}%; transition:width 0.3s ease;"></div>
                                </div>
                            </div>
                            <span class="breakdown-val" style="color:${color}; font-weight:bold; min-width:50px; text-align:right">${item.val_str}</span>
                        </div>
                    `;
                }).join('');
            } else {
                bd.innerHTML = '<div style="color:#999; text-align:center; padding:12px; font-size:0.9em;">ëŒ€ê¸° ì¤‘...</div>';
            }

            // ê²Œì„ ì¢…ë£Œ ìƒíƒœë©´ ì–‘ìª½ ëª¨ë‘ ì¢…ë£Œ ë©”ì‹œì§€ í‘œì‹œ
            if (GameState.isGameOver()) {
                const statusEl = document.getElementById('game-status');
                if (statusEl) {
                    const myTotal = calcTotals(GameState.getMyCard()).total;
                    const oppTotal = calcTotals(GameState.getOppCard()).total;
                    const msg = isMultiplayer ? `ğŸ‰ ê²Œì„ ì¢…ë£Œ! ë‚˜ ${myTotal} : ìƒëŒ€ ${oppTotal}` : `ğŸ‰ ê²Œì„ ì¢…ë£Œ! ìµœì¢… ì ìˆ˜: ${myTotal}`;
                    statusEl.innerText = msg;
                }
                const myTotal = calcTotals(GameState.getMyCard()).total;
                const oppTotal = calcTotals(GameState.getOppCard()).total;
                showGameOverToast(myTotal, oppTotal);
            }
            
            refreshTurnUI();
            updateDice();
            updateScorecard();
            isApplyingRemote = false;
        }

        async function fetchRoomState() {
            if (!isMultiplayer || !roomCode) {
                return Promise.resolve();
            }
            return new Promise((resolve) => {
                fetch(`/api/rooms/${roomCode}?u=${encodeURIComponent(username)}`)
                    .then(async (r) => {
                        if (r.status === 404) {
                            handleConnectionLost();
                            resolve();
                            return;
                        }
                        const data = await r.json();
                        syncFailures = 0; // ì„±ê³µ ì‹œ ì‹¤íŒ¨ ì¹´ìš´í„° ì´ˆê¸°í™”
                        if (data.players) {
                            const prevPlayerCount = roomPlayers.length;
                            roomPlayers = data.players;
                            // ë‚´ê°€ ëª©ë¡ì— ì—†ë‹¤ë©´ ê°•í‡´/ì´íƒˆë¡œ ê°„ì£¼í•˜ê³  ì¢…ë£Œ
                            if (!roomPlayers.includes(username)) {
                                handleConnectionLost();
                                resolve();
                                return;
                            }
                            
                            // ìƒëŒ€ë°© ì´íƒˆ ê°ì§€: í”Œë ˆì´ì–´ê°€ ì¤„ì–´ë“¤ì—ˆì§€ë§Œ ë‚´ê°€ ë‚¨ì•„ìˆë‹¤ë©´ ê³„ì† ì§„í–‰
                            // (ë” ì´ìƒ ìë™ í‡´ì¥í•˜ì§€ ì•ŠìŒ)
                            
                            const opp = roomPlayers.find(p => p !== username);
                            if (opp && opp !== opponentName) {
                                opponentName = opp;  // ìƒˆë¡œ ê°ì§€ëœ ê²ŒìŠ¤íŠ¸
                                console.log('ìƒëŒ€ ì…ì¥:', opp);
                            }
                        }
                        if (data.state) {
                            applyRemoteState(data.state);
                        }
                        resolve();
                    })
                    .catch(e => {
                        console.warn('pull failed', e);
                        syncFailures++;
                        if (syncFailures >= 3) {
                            handleConnectionLost('ì—°ê²° ìƒíƒœë¥¼ í™•ì¸í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ë¡œë¹„ë¡œ ì´ë™í•©ë‹ˆë‹¤.');
                            resolve();
                            return;
                        }
                        resolve();
                    });
            });
        }

        function startSyncPolling() {
            if (!isMultiplayer || syncTimer) return;
            fetchRoomState();
            syncTimer = setInterval(fetchRoomState, 1200);
        }

        async function rollDice() {
            if (rollsLeft <= 0 || gameOver || isRolling || !isMyTurn()) return;
            if (isMultiplayer && (!opponentName || roomPlayers.length < 2)) {
                alert('ìƒëŒ€ë°©ì´ ì…ì¥í•  ë•Œê¹Œì§€ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”!');
                return;
            }
            
            // Web Audio APIë¡œ ì£¼ì‚¬ìœ„ êµ´ëŸ¬ê°€ëŠ” ì†Œë¦¬ ìƒì„±
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const now = audioContext.currentTime;
                const duration = 0.4;
                
                // ë…¸ì´ì¦ˆ ìƒì„± (ì£¼ì‚¬ìœ„ êµ´ëŸ¬ê°€ëŠ” ì†Œë¦¬)
                const bufferSize = audioContext.sampleRate * duration;
                const noiseBuffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
                const output = noiseBuffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    output[i] = Math.random() * 2 - 1;
                }
                const noiseSource = audioContext.createBufferSource();
                noiseSource.buffer = noiseBuffer;
                
                // ë…¸ì´ì¦ˆìš© ê²Œì¸
                const noiseGain = audioContext.createGain();
                noiseSource.connect(noiseGain);
                noiseGain.connect(audioContext.destination);
                noiseGain.gain.setValueAtTime(0.2, now);
                noiseGain.gain.exponentialRampToValueAtTime(0.01, now + duration);
                
                // ë¹ ë¥´ê²Œ ë°˜ë³µë˜ëŠ” í†¤ (ë”¸ê¹ë”¸ê¹ë”¸ê¹ ì†Œë¦¬)
                const beatDuration = 0.08;
                for (let beat = 0; beat < 5; beat++) {
                    const osc = audioContext.createOscillator();
                    const gain = audioContext.createGain();
                    osc.type = 'square';
                    // ë‚®ì•„ì§€ëŠ” ì£¼íŒŒìˆ˜ (1200 -> 400)
                    const freqRange = 1200 - (beat * 160);
                    osc.frequency.value = Math.max(freqRange, 400);
                    osc.connect(gain);
                    gain.connect(audioContext.destination);
                    
                    const startTime = now + (beat * 0.07);
                    gain.gain.setValueAtTime(0.12, startTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, startTime + beatDuration);
                    
                    osc.start(startTime);
                    osc.stop(startTime + beatDuration);
                }
                
                noiseSource.start(now);
                noiseSource.stop(now + duration);
            } catch (e) {
                console.warn('Audio context failed:', e);
            }

            isRolling = true;
            aiRec = null; // ì´ì „ ì¶”ì²œ ì •ë³´ ì¦‰ì‹œ ì‚­ì œ (í™”ë©´ ë¶ˆì¼ì¹˜ ë°©ì§€)
            document.getElementById('ai-breakdown').innerHTML = '<div style="color:#999; text-align:center; padding:12px; font-size:0.9em;">ğŸ² ê³„ì‚° ì¤‘...</div>';
            updateDice(); // UI ê°±ì‹  (ë²„íŠ¼ ë¹„í™œì„±í™” ë° ì´ì „ í•˜ì´ë¼ì´íŠ¸ ì œê±°)

            for (let i = 0; i < 5; i++) {
                if (!kept[i]) document.getElementById(`die-${i}`).classList.add('rolling');
            }
            
            setTimeout(async () => {
                try {
                    // ì„œë²„ì—ì„œ ì£¼ì‚¬ìœ„ êµ´ë¦¼ (í´ë¼ì´ì–¸íŠ¸ ì¡°ì‘ ë°©ì§€)
                    if (isMultiplayer && roomCode) {
                        const r = await fetch(`/api/rooms/${roomCode}/roll`, {
                            method: 'POST',
                            headers: {'Content-Type': 'application/json'},
                            body: JSON.stringify({username, kept})
                        });
                        const data = await r.json();
                        if (data.dice && typeof data.rolls_left === 'number') {
                            dice = data.dice;
                            rollsLeft = data.rolls_left;
                            // GameStateì— ì¦‰ì‹œ ë°˜ì˜ (ë‚´ í™”ë©´ì— ë‚´ ì£¼ì‚¬ìœ„ê°€ ë³´ì´ë„ë¡)
                            GameState.setDice(dice);
                            GameState.setKept(kept);
                            GameState.setRollsLeft(rollsLeft);
                        } else {
                            alert('ì£¼ì‚¬ìœ„ êµ´ë¦¼ ì‹¤íŒ¨');
                            isRolling = false;
                            return;
                        }
                    } else {
                        // ì‹±ê¸€í”Œë ˆì´ ëª¨ë“œ - í´ë¼ì´ì–¸íŠ¸ì—ì„œë§Œ êµ´ë¦¼
                        // rollsLeft ì¬ê²€ì¦
                        if (rollsLeft <= 0) {
                            alert('ë‚¨ì€ êµ´ë¦¼ì´ ì—†ìŠµë‹ˆë‹¤');
                            isRolling = false;
                            return;
                        }
                        for (let i = 0; i < 5; i++) {
                            if (!kept[i]) dice[i] = Math.floor(Math.random() * 6) + 1;
                        }
                        rollsLeft--;
                        GameState.setDice(dice);
                        GameState.setKept(kept);
                        GameState.setRollsLeft(rollsLeft);
                    }
                    
                    isRolling = false;
                    updateDice();
                    updateScorecard();
                    await askAI();
                    pushState();
                } catch (e) {
                    console.error('Roll failed:', e);
                    isRolling = false;
                }
            }, 600);
        }

        async function askAI() {
            console.log('askAI í˜¸ì¶œ - gameOver:', gameOver, 'isMyTurn():', isMyTurn(), 'turnOwner:', turnOwner, 'username:', username);
            if (gameOver || !isMyTurn()) return;
            try {
                // scorecardì—ì„œ nullì¸ ì¸ë±ìŠ¤ë§Œ ì¶”ì¶œí•˜ì—¬ open_categories ìƒì„±
                const open_categories = myCard.map((v, i) => v === null ? i : null).filter(v => v !== null);
                const r = await fetch('/api/recommend', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({dice, rolls_left: rollsLeft, scorecard: myCard, open_categories})
                });
                aiRec = await r.json();
                
                // AI ë¶„ì„ ë¦¬ìŠ¤íŠ¸ í‘œì‹œ
                const bd = document.getElementById('ai-breakdown');
                if (aiRec.breakdown && aiRec.breakdown.length > 0) {
                    bd.innerHTML = aiRec.breakdown.map(item => {
                        let color = '#ffd700';
                        
                        // ì‹œê°ì  ë°” í‘œí˜„
                        const barWidth = Math.min(item.prob * 100, 100);
                        return `
                            <div class="breakdown-item">
                                <div style="flex: 1;">
                                    <div style="display:flex; align-items:center; gap:8px; margin-bottom:4px;">
                                        <span style="font-size:1.3em; font-weight:bold; color:${color}">â¤</span>
                                        <span style="color:#ccc; font-weight:500">${item.name}</span>
                                    </div>
                                    <div style="font-size:0.9em; color:#aaa; margin-top:3px; margin-bottom:6px;">${item.keep_str}</div>
                                    <div style="background:rgba(0,0,0,0.3); border-radius:6px; height:6px; margin-right:8px;">
                                        <div style="background:${color}; border-radius:6px; height:100%; width:${barWidth}%; transition:width 0.3s ease;"></div>
                                    </div>
                                </div>
                                <span class="breakdown-val" style="color:${color}; font-weight:bold; min-width:50px; text-align:right">${item.val_str}</span>
                            </div>
                        `;
                    }).join('');
                } else {
                    bd.innerHTML = '<div style="color:#999; text-align:center; padding:12px; font-size:0.9em;">ëŒ€ê¸° ì¤‘...</div>';
                }
                
                updateDice();
            } catch (e) {
                console.error(e);
            }
        }

        function calcScore(d, i) {
            const c = {};
            d.forEach(x => c[x] = (c[x] || 0) + 1);
            if (i < 6) return (c[i+1] || 0) * (i+1);
            if (i === 6) return d.reduce((a, b) => a + b); // Choice
            if (i === 7) { // 4 of a Kind (5ê°œ ì „ì²´ í•©ì‚°)
                const mc = Object.entries(c).find(([k, v]) => v >= 4);
                return mc ? d.reduce((a, b) => a + b) : 0;
            }
            if (i === 8) { // Full House (í•©ê³„)
                const v = Object.values(c).sort();
                if (v.length === 1) return d.reduce((a, b) => a + b); // 5 of a kind
                if (v.length === 2 && v[0] === 2 && v[1] === 3) return d.reduce((a, b) => a + b);
                return 0;
            }
            if (i === 9) { // Single Straight (ì—°ì† 4ê°œ, 15ì )
                const u = [...new Set(d)].sort((a,b) => a-b);
                // 1-2-3-4, 2-3-4-5, 3-4-5-6 ì¤‘ í•˜ë‚˜
                const straights = [[1,2,3,4], [2,3,4,5], [3,4,5,6]];
                return straights.some(s => s.every(x => u.includes(x))) ? 15 : 0;
            }
            if (i === 10) { // Large Straight (ì—°ì† 5ê°œ, 30ì )
                const u = [...new Set(d)].sort((a,b) => a-b);
                // 1-2-3-4-5 ë˜ëŠ” 2-3-4-5-6
                return ([1,2,3,4,5].every(x => u.includes(x)) || [2,3,4,5,6].every(x => u.includes(x))) ? 30 : 0;
            }
            if (i === 11) return Object.values(c).includes(5) ? 50 : 0; // Yacht
            return 0;
        }

        function calcTotals(card) {
            const upper = card.slice(0, 6).reduce((a, v) => a + (v || 0), 0);
            const bonus = upper >= 63 ? 35 : 0;
            const lower = card.slice(6).reduce((a, v) => a + (v || 0), 0);
            return { upper, bonus, total: upper + bonus + lower };
        }

        function renderCard(card, isMine, title) {
            const totals = calcTotals(card);
            let h = '';
            CATS.forEach((c, i) => {
                if (i === 6) {
                    h += `<div class="score-item subtotal" style="background:rgba(255,255,255,0.1); cursor:default;" data-desc="ìƒë‹¨ í•­ëª©(Ones~Sixes)ì˜ ì ìˆ˜ í•©ê³„. ëª©í‘œëŠ” 63ì  (ê° ìˆ«ì 3ê°œì”©)" data-dice="" onmouseenter="showTip(this)" onmouseleave="hideTip(this)"><span class="score-name">Subtotal (1-6)</span><span class="score-val">${totals.upper}/63</span></div>`;
                    h += `<div class="score-item bonus" data-desc="ìƒë‹¨ í•©ê³„ê°€ 63ì  ì´ìƒì´ë©´ ë³´ë„ˆìŠ¤ 35ì  ì¶”ê°€&#10;&#10;ë‹¬ì„± ë°©ë²•: ê° ìˆ«ìë¥¼ 3ê°œì”© ëª¨ìœ¼ê¸°&#10;(1Ã—3 + 2Ã—3 + 3Ã—3 + 4Ã—3 + 5Ã—3 + 6Ã—3 = 63ì )" data-dice="" onmouseenter="showTip(this)" onmouseleave="hideTip(this)"><span class="score-name">Upper Bonus (63+)</span><span class="score-val">+${totals.bonus}</span></div>`;
                }
                const clickable = isMine && !gameOver && isMyTurn() && card[i] === null && rollsLeft < 3;
                const showPreview = !gameOver && card[i] === null && rollsLeft < 3 && ((isMine && isMyTurn()) || (!isMine && !isMyTurn()));
                const sc = calcScore(dice, i);
                const p = showPreview ? `<span class="score-preview">(${sc})</span>` : '';
                const classes = `score-item ${card[i] !== null ? 'filled' : ''} ${!isMine ? 'disabled' : ''}`;
                const desc = CAT_DESC[c] || '';
                const diceEx = 'ì˜ˆì‹œ) ' + CAT_DICE[c] || '';
                const handlers = clickable
                    ? `onclick="pickCategory(${i})" onmouseenter="showTip(this); previewScore(${i})" onmouseleave="hideTip(this); clearPreview()"`
                    : `onmouseenter="showTip(this)" onmouseleave="hideTip(this)"`;
                h += `<div class="${classes}" ${handlers} data-desc="${desc}" data-dice="${diceEx}"><span class="score-name">${c}</span><span class="score-val">${card[i] !== null ? card[i] : '-'}${p}</span></div>`;
            });
            h += `<div class="total-score"><span>TOTAL</span><span>${totals.total}</span></div>`;
            
            // í˜„ì¬ í„´ ì—¬ë¶€ íŒë‹¨
            const isCurrentTurn = isMultiplayer ? (isMine ? isMyTurn() : !isMyTurn()) : isMine;
            const titleStyle = isCurrentTurn ? 'color: #00ff00; text-shadow: 0 0 20px rgba(0, 255, 0, 0.8); font-weight: bold;' : 'color: #00ffcc;';
            
            return `<div class="scorecard-title" style="${titleStyle}">${title}</div><div>${h}</div>`;
        }

        function updateScorecard() {
            const el = document.getElementById('scorecard');
            if (!el) return;
            if (isMultiplayer) {
                const oppLabel = opponentName || 'ìƒëŒ€ ëŒ€ê¸° ì¤‘';
                el.innerHTML = `
                <div style="display:flex; gap:16px; flex-wrap:wrap;">
                    <div style="flex:1; min-width:280px;">${renderCard(myCard, true, 'ë‚˜ (' + username + ')')}</div>
                    <div style="flex:1; min-width:280px;">${renderCard(oppCard, false, 'ìƒëŒ€ (' + oppLabel + ')')}</div>
                </div>`;
            } else {
                el.innerHTML = renderCard(myCard, true, 'ì ìˆ˜í‘œ');
            }
        }

        function previewScore(i) {
            if (myCard[i] !== null || rollsLeft === 3 || gameOver || !isMyTurn()) return;
            const sc = calcScore(dice, i);
            const curTotals = calcTotals(myCard);
            const temp = [...myCard];
            temp[i] = sc;
            const newTotals = calcTotals(temp);

            const totalEl = document.querySelector('.scorecard-area .total-score span:last-child');
            if (totalEl) {
                const diff = newTotals.total - curTotals.total;
                totalEl.innerHTML = `${curTotals.total} <span style="color:#00ffcc; font-size:0.8em"> (+${diff}) âœ ${newTotals.total}</span>`;
            }

            if (i < 6) {
                const bonusEl = document.querySelector('.score-item.bonus .score-val');
                if (bonusEl && newTotals.bonus > curTotals.bonus) {
                    bonusEl.innerHTML = `+${curTotals.bonus} <span style="color:#ffd700; font-weight:bold"> (+35) âœ ${newTotals.bonus}</span>`;
                    bonusEl.parentElement.style.background = 'rgba(255, 215, 0, 0.25)';
                }
            }
        }

        function clearPreview() {
            updateScorecard();
        }

        // ì»¤ìŠ¤í…€ íˆ´íŒ
        function showTip(el) {
            hideTip(el);
            const desc = el.getAttribute('data-desc') || '';
            const dice = el.getAttribute('data-dice') || '';
            if (!desc && !dice) return;
            const tip = document.createElement('div');
            tip.className = 'custom-tip';
            tip.innerHTML = `<div class="tip-dice">${dice}</div><div class="tip-desc">${desc}</div>`;
            el.appendChild(tip);
        }
        function hideTip(el) {
            const tip = el.querySelector('.custom-tip');
            if (tip) tip.remove();
        }

        function showToast(category, score) {
            const toast = document.getElementById('score-toast');
            toast.innerHTML = `<div class="toast-cat">${category}</div><div class="toast-score">+${score}</div>`;
            toast.classList.add('show');
            
            // ì•Œë¦¼ìŒ ì¬ìƒ
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const now = audioContext.currentTime;
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                osc.connect(gain);
                gain.connect(audioContext.destination);
                osc.frequency.value = 1000;
                gain.gain.setValueAtTime(0.3, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                osc.start(now);
                osc.stop(now + 0.15);
            } catch (e) {
                console.warn('Toast audio failed:', e);
            }
            
            setTimeout(() => {
                toast.classList.remove('show');
            }, 1500);
        }

        function pickCategory(i) {
            if (!isMyTurn() || myCard[i] !== null || rollsLeft === 3 || gameOver) return;
            
            let score = calcScore(dice, i);
            
            // Yacht ë³´ë„ˆìŠ¤: Yachtê°€ ë‘ ë²ˆ ì´ìƒ ë‚˜ì˜¨ ê²½ìš° (Yacht ì¹¸ì— +100ì )
            let yachtBonus = 0;
            if (calcScore(dice, 11) === 50 && myCard[11] >= 50 && i !== 11 && score > 0) {
                // í˜„ì¬ Yachtê°€ ë‚˜ì™”ê³ , Yacht ì¹¸ì— ì´ë¯¸ 50ì ì´ ê¸°ë¡ë˜ì–´ ìˆê³ , 0ì´ ì•„ë‹Œ ì ìˆ˜ë¥¼ ê¸°ë¡í•  ë•Œ
                yachtBonus = 100;
                myCard[11] += yachtBonus;  // Yacht ì¹¸ì— ë³´ë„ˆìŠ¤ ëˆ„ì 
            }
            
            // ì¼ë°˜ ì ìˆ˜ ê¸°ë¡
            myCard[i] = score;
            if (yachtBonus > 0) {
                showToast(`ğŸ† Yacht Bonus: ${CATS[i]} +${score}ì , Yacht +100ì `, score);
            } else {
                showToast(CATS[i], score);
            }
            
            dice = [1,1,1,1,1];
            kept = [0,0,0,0,0];
            rollsLeft = 3;
            aiRec = null;

            // í„´ ì „í™˜
            if (isMultiplayer && opponentName) {
                turnOwner = opponentName;
            }

            // ê²Œì„ ì¢…ë£Œ ì²´í¬ (ì–‘ìª½ ì ìˆ˜í‘œê°€ ëª¨ë‘ ì±„ì›Œì¡Œì„ ë•Œ)
            const myDone = myCard.every(v => v !== null);
            const oppDone = opponentName ? oppCard.every(v => v !== null) : true;
            if (myDone && (oppDone || !isMultiplayer)) {
                gameOver = true;
                const myTotal = calcTotals(myCard).total;
                const oppTotal = calcTotals(oppCard).total;
                const resultMsg = isMultiplayer ? `ë‚˜ ${myTotal} : ìƒëŒ€ ${oppTotal}` : `ìµœì¢… ì ìˆ˜: ${myTotal}`;
                const statusEl = document.getElementById('game-status');
                if (statusEl) statusEl.innerText = `ğŸ‰ ê²Œì„ ì¢…ë£Œ! ${resultMsg}`;

                showGameOverToast(myTotal, oppTotal);

                // ê²Œì„ ê²°ê³¼ ì €ì¥ (ë‘ í”Œë ˆì´ì–´)
                if (username) {
                    const p2 = opponentName || null;
                    saveGameResult(username, myTotal, p2, oppTotal || 0);
                }
            }

            // ë¡œì»¬/ì „ì—­ ìƒíƒœ ë™ê¸°í™” (UIì™€ ì„œë²„ ì „íŒŒìš©)
            GameState.setState({
                dice: [...dice],
                kept: [...kept],
                rollsLeft,
                myCard: [...myCard],
                oppCard: [...oppCard],
                gameOver,
                aiRec,
            });

            updateDice();
            updateScorecard();
            refreshTurnUI();
            pushState();
        }

        function resetGame() {
            // í™•ì¸ ë©”ì‹œì§€
            if (!confirm('ğŸ”„ ìƒˆ ê²Œì„ì„ ì‹œì‘í•˜ì‹œê² ìŠµë‹ˆê¹Œ?\n\ní˜„ì¬ ê²Œì„ ì§„í–‰ ìƒí™©ì´ ëª¨ë‘ ì´ˆê¸°í™”ë©ë‹ˆë‹¤.')) {
                return;
            }

            // ì‹±ê¸€ í”Œë ˆì´: í˜ì´ì§€ ìƒˆë¡œê³ ì¹¨ìœ¼ë¡œ ì™„ì „ ì´ˆê¸°í™”
            if (!isMultiplayer) {
                location.reload();
                return;
            }

            // ë©€í‹° í”Œë ˆì´: ì„œë²„ ë™ê¸°í™” í•„ìš”
            if (!isMyTurn()) return;
            
            // ê²Œì„ ìƒíƒœ ì™„ì „ ì´ˆê¸°í™”
            dice = [1,1,1,1,1];
            kept = [0,0,0,0,0];
            rollsLeft = 3;
            myCard = Array(12).fill(null);
            if (opponentName) {
                oppCard = Array(12).fill(null);
                turnOwner = username;
            }
            gameOver = false;
            gameOverToastShown = false;
            aiRec = null;
            
            // UI ì™„ì „ ìƒˆë¡œê³ ì¹¨
            updateDice();
            updateScorecard();
            refreshTurnUI();
            
            // ì£¼ì‚¬ìœ„ ì ê¸ˆ í•´ì œ ë° ë²„íŠ¼ ì´ˆê¸°í™”
            for (let i = 0; i < 5; i++) {
                const diceContainer = document.querySelectorAll('.die-container')[i];
                const keepBtn = document.querySelectorAll('.keep-btn')[i];
                if (diceContainer) {
                    diceContainer.classList.remove('locked');
                }
                if (keepBtn) {
                    keepBtn.textContent = 'REROLL';
                    keepBtn.classList.remove('active-keep', 'active-reroll');
                    keepBtn.classList.add('active-reroll');
                }
            }
            
            // AI ì¶”ì²œ íŒ¨ë„ ì´ˆê¸°í™”
            const aiPanel = document.getElementById('ai-panel');
            if (aiPanel) {
                aiPanel.style.display = 'none';
            }
            
            pushState();
        }

        function saveGameResult(username, finalScore, player2 = null, score2 = 0) {
            fetch('/api/save-game', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({
                    player1: username,
                    score1: finalScore,
                    player2,
                    score2
                })
            })
            .then(r => r.json())
            .then(data => {
                if (data.status === 'success') {
                    setTimeout(() => {
                        alert(`ê²Œì„ ì¢…ë£Œ!\n\nìµœì¢… ì ìˆ˜: ${finalScore}ì \n\në¡œë¹„ë¡œ ì´ë™í•©ë‹ˆë‹¤.`);
                        window.location.replace('/');
                    }, 800);
                }
            })
            .catch(e => console.error('Failed to save game:', e));
        }

        async function leaveRoom() {
            if (!confirm('ì •ë§ ë‚˜ê°€ì‹œê² ìŠµë‹ˆê¹Œ?')) return;
            
            if (isMultiplayer && roomCode) {
                // ë©€í‹°í”Œë ˆì´ì–´ ëª¨ë“œ: ë°©ì—ì„œ ë‚˜ê°€ê¸°
                try {
                    const payload = JSON.stringify({username});
                    // ë¸Œë¼ìš°ì €ê°€ íƒ­ì„ ë‹«ì•„ë„ ì „ì†¡ë˜ë„ë¡ sendBeacon ìš°ì„  ì‚¬ìš©
                    if (navigator.sendBeacon) {
                        const url = `/api/rooms/${roomCode}/leave?username=${encodeURIComponent(username)}`;
                        navigator.sendBeacon(url, payload);
                    } else {
                        fetch(`/api/rooms/${roomCode}/leave`, {
                            method: 'POST',
                            headers: {'Content-Type': 'application/json'},
                            body: payload,
                            keepalive: true,
                            cache: 'no-store',
                        }).catch((e) => console.warn('leave failed (non-blocking)', e));
                    }
                    localStorage.removeItem('yacht_room');
                    // ì¤‘ë„ í‡´ì‹¤ì€ íŒ¨ë°° ì²˜ë¦¬ë˜ë¯€ë¡œ ìŠ¹ë¦¬ íŒì—… ì–µì œ
                    gameOverToastShown = true;
                    alert('ë¡œë¹„ë¡œ ì´ë™í•©ë‹ˆë‹¤');
                } catch (e) {
                    console.error('Leave failed', e);
                    alert('ë‚˜ê°€ê¸° ì‹¤íŒ¨');
                    return;
                }
            }

            // ì‹±ê¸€/ë©€í‹° ëª¨ë‘ ë¡œë¹„ë¡œ ë°”ë¡œ ì´ë™ (ì‘ë‹µ ëŒ€ê¸° ì—†ì´)
            window.location.replace('/');
        }

        function passTurn() {
            // ì²« êµ´ë¦¼ ì „(rollsLeft=3)ì´ê³  ì ìˆ˜ ê¸°ë¡ì´ í•˜ë‚˜ë„ ì—†ì„ ë•Œë§Œ í—ˆìš©
            const myEmpty = GameState.getMyCard().every(v => v === null);
            const oppEmpty = GameState.getOppCard().every(v => v === null);
            if (!isMultiplayer || !opponentName || !isMyTurn() || GameState.getRollsLeft() !== 3 || !myEmpty || !oppEmpty) return;
            
            // í„´ì„ ìƒëŒ€ë°©ì—ê²Œ ë„˜ê¹€
            turnOwner = opponentName;
            refreshTurnUI();
            updateDice();
            updateScorecard();
            pushState();
            
            // ì‚¬ìš©ì ì•Œë¦¼
            const toast = document.getElementById('score-toast');
            toast.innerHTML = `<div style="font-size:0.8em;">ì„ ê³µê¶Œì„ ${opponentName}ë‹˜ì—ê²Œ ë„˜ê²¼ìŠµë‹ˆë‹¤</div>`;
            toast.classList.add('show');
            playTurnToastSound();
            setTimeout(() => {
                toast.classList.remove('show');
            }, 2000);
        }

        // ë¹„ë™ê¸° ì´ˆê¸°í™”
        async function initializeGame() {
            // ì´ˆê¸° í™”ë©´ ë Œë”ë§
            renderDice();
            updateScorecard();
            document.getElementById('ai-breakdown').innerHTML = '<div style="color:#999; text-align:center; padding:12px; font-size:0.9em;">ğŸ² ì£¼ì‚¬ìœ„ë¥¼ êµ´ë ¤ì£¼ì„¸ìš”</div>';
            const roomLabel = document.getElementById('room-label');
            if (roomLabel) {
                roomLabel.textContent = roomCode ? `Room ${roomCode}` : '';
            }
            
            // ë©€í‹°í”Œë ˆì´ì–´ ì „ìš© ë²„íŠ¼ í‘œì‹œ/ìˆ¨ê¸°ê¸°
            const multiControls = document.getElementById('multiplayer-controls');
            if (multiControls) {
                multiControls.style.display = isMultiplayer ? 'flex' : 'none';
            }
            
            // NEW GAME ë²„íŠ¼: ì‹±ê¸€ ëª¨ë“œì—ë§Œ í‘œì‹œ
            const newGameBtn = document.getElementById('new-game-btn');
            if (newGameBtn) {
                newGameBtn.style.display = isMultiplayer ? 'none' : 'flex';
            }
            
            // ë©€í‹°í”Œë ˆì´ì–´ ê²Œì„ì˜ ê²½ìš° ë¨¼ì € ë°© ìƒíƒœë¥¼ ë¡œë“œ
            if (isMultiplayer) {
                try {
                    await fetchRoomState();  // ì´ˆê¸° ìƒíƒœ ë¡œë“œ
                } catch (e) {
                    console.warn('Failed to fetch initial room state:', e);
                }
                startSyncPolling();  // í´ë§ ì‹œì‘
            }
            refreshTurnUI();
        }

        // ê²Œì„ ì´ˆê¸°í™” ì‹œì‘
        initializeGame().catch(e => console.error('Initialization error:', e));
    </script>
</body>
</html>
