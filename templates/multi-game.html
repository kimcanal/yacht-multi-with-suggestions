<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ² Yacht - Multiplayer</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            background: linear-gradient(135deg, #0f0f1e 0%, #1a1a3e 100%);
            color: #fff; 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            min-height: 100vh;
            padding: 20px;
        }
        @media (max-width: 995px) {
            body { padding: 10px; }
        }
        .game-wrapper {
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            gap: 40px;
            flex-wrap: wrap;
            justify-content: center;
            align-items: flex-start;
        }
        .main-area {
            flex: 1 1 400px;
            max-width: 100%;
        }
        .title {
            font-size: 3em;
            font-weight: 700;
            margin-bottom: 30px;
            text-shadow: 0 0 30px rgba(0, 255, 200, 0.3);
            color: #00ffcc;
        }
        .dice-area {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 20px;
            padding: 40px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            margin-bottom: 30px;
        }
        .dice-grid {
            display: flex;
            flex-wrap: nowrap;
            gap: 8px;
            justify-content: space-between;
            margin-bottom: 20px;
            width: 100%;
        }
        .dice-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            flex: 1;
            min-width: 0;
            font-size: min(3.1vw, 22px);
        }
        .die-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }
        .keep-btn {
            padding: 6px 12px;
            font-size: 12px;
            font-weight: bold;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.05);
            color: #fff;
            cursor: pointer;
            transition: all 0.2s ease;
            min-width: 0;
            width: 100%;
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .keep-btn:hover {
            border-color: rgba(0, 255, 200, 0.6);
            background: rgba(0, 255, 200, 0.1);
        }
        .keep-btn.active-keep {
            border-color: #00ff00;
            background: rgba(0, 255, 0, 0.2);
            color: #00ff00;
            font-weight: bold;
        }
        .keep-btn.active-reroll {
            border-color: #ff4444;
            background: rgba(255, 68, 68, 0.2);
            color: #ff4444;
            font-weight: bold;
        }
        .die-container {
            width: 5em;
            height: 5em;
            position: relative;
            perspective: 1000px;
            transition: transform 0.3s ease;
        }
        .die-container.locked {
            transform: translateY(-15px);
        }
        .die {
            width: 100%;
            height: 100%;
            position: absolute;
            transform-style: preserve-3d;
            transition: transform 0.8s cubic-bezier(0.2, 0.8, 0.2, 1);
        }
        .die-face {
            position: absolute;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(255,255,255,0.98), rgba(240,240,240,0.9));
            border: 2px solid rgba(200,200,200,0.5);
            border-radius: 0.8em;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            padding: 0.4em;
            backface-visibility: hidden;
            box-shadow: inset 0 0 15px rgba(0,0,0,0.05);
        }
        .die-face .dot { margin: auto; box-shadow: inset 0 1px 3px rgba(0,0,0,0.5); }
        .face-1 { transform: rotateY(0deg) translateZ(2.5em); }
        .face-6 { transform: rotateY(180deg) translateZ(2.5em); }
        .face-2 { transform: rotateX(90deg) translateZ(2.5em); }
        .face-5 { transform: rotateX(-90deg) translateZ(2.5em); }
        .face-3 { transform: rotateY(90deg) translateZ(2.5em); }
        .face-4 { transform: rotateY(-90deg) translateZ(2.5em); }
        .die.rolling { animation: roll3d 1.5s linear infinite; }
        @keyframes roll3d {
            0% { transform: rotateX(0) rotateY(0) rotateZ(0); }
            100% { transform: rotateX(720deg) rotateY(360deg) rotateZ(360deg); }
        }
        .dot { width: 0.9em; height: 0.9em; background: #333; border-radius: 50%; transition: all 0.2s; }
        .dot.hidden { opacity: 0; }
        .controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 10px;
            margin-bottom: 30px;
        }
        .btn {
            padding: 12px 30px;
            font-size: 16px;
            font-weight: 600;
            border: none;
            border-radius: 30px;
            cursor: pointer;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
            transition: all 0.3s ease;
        }
        .btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 25px rgba(102, 126, 234, 0.6);
        }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .info-bar {
            background: rgba(0, 255, 204, 0.1);
            border: 2px solid #00ffcc;
            border-radius: 15px;
            padding: 15px;
            text-align: center;
            font-size: 1.2em;
            color: #00ffcc;
            font-weight: bold;
        }
        .rolls-remaining { font-size: 1.5em; margin-bottom: 15px; }
        .scorecard-area {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 20px;
            padding: 30px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            flex: 1 1 350px;
            max-width: 100%;
            margin: 0 auto;
        }
        @media (max-width: 995px) {
            .game-wrapper { gap: 24px; }
            .main-area { max-width: 480px; }
            .scorecard-area { max-width: 450px; }
            .dice-area { padding: 20px 12px; }
            .dice-grid { flex-wrap: wrap; justify-content: center; gap: 8px; width: 100%; }
            .dice-item { width: auto; flex: 0 0 30%; font-size: min(6vw, 22px); }
            .keep-btn { width: 100%; font-size: 11px; padding: 6px 0; }
        }
        @media (max-width: 480px) {
            .game-wrapper { gap: 16px; }
            .dice-area { padding: 16px 10px; }
            .scorecard-area { padding: 20px 12px; }
        }
        .scorecard-title {
            font-size: 1.8em;
            font-weight: 700;
            margin-bottom: 25px;
            color: #00ffcc;
            text-align: center;
        }
        .score-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 14px 16px;
            margin: 8px 0;
            font-size: 1.05em;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            border-left: 4px solid transparent;
            position: relative;
        }
        .score-item:hover:not(.filled):not(.bonus) {
            background: rgba(102, 126, 234, 0.3);
            border-left-color: #667eea;
            transform: translateX(5px);
        }
        .score-item.filled { background: rgba(0, 255, 204, 0.15); cursor: default; border-left-color: #00ffcc; }
        .score-item.bonus { background: rgba(255, 215, 0, 0.15); border-left-color: #ffd700; font-weight: bold; cursor: default; }
        .score-name { font-weight: 500; font-size: 1.05em; flex: 1; }
        .score-val { font-weight: bold; color: #ffd700; font-size: 1.1em; min-width: 60px; text-align: right; }
        .score-preview { font-size: 0.85em; color: #00ffcc; margin-left: 10px; opacity: 0.8; }
        
        .total-score {
            margin-top: 20px; padding-top: 20px; border-top: 2px solid rgba(255, 255, 255, 0.2);
            display: flex; justify-content: space-between; font-size: 1.3em; font-weight: bold; color: #ffd700;
        }
        .ai-breakdown {
            margin-top: 15px; background: rgba(0, 0, 0, 0.3); border-radius: 10px;
            padding: 12px; font-size: 0.9em; text-align: left;
        }
        .breakdown-item {
            display: flex; justify-content: space-between; align-items: center;
            padding: 8px 10px; border-bottom: 1px solid rgba(255, 255, 255, 0.05); gap: 10px;
        }
        .breakdown-item:last-child { border-bottom: none; }
        .breakdown-val { color: #00ffcc; font-weight: bold; }
        .toast-overlay {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%) scale(0.9);
            background: rgba(20, 20, 40, 0.95); color: #fff; padding: 30px 50px;
            border-radius: 20px; font-size: 2em; font-weight: 800; text-align: center;
            z-index: 2000; pointer-events: none; opacity: 0;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            border: 2px solid #00ffcc; box-shadow: 0 0 50px rgba(0, 255, 204, 0.4);
            display: flex; flex-direction: column; gap: 10px;
        }
        .toast-overlay.show { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        .toast-cat { font-size: 0.6em; color: #aaa; text-transform: uppercase; letter-spacing: 2px; }
        .toast-score { font-size: 1.5em; color: #ffd700; text-shadow: 0 0 20px rgba(255, 215, 0, 0.5); }
        @media (max-width: 767px) {
            .toast-overlay { padding: 20px 30px; font-size: 1.3em; border-radius: 15px; max-width: 85%; }
            body { padding: 6px; }
            .game-wrapper { width: 100%; max-width: 100%; padding: 0; margin: 0; }
            .main-area { max-width: 100%; }
            .dice-area { width: 100%; max-width: 100%; margin: 0 auto; padding: 16px 2px; }
            .dice-grid { flex-wrap: wrap; justify-content: center; gap: 8px; width: 100%; max-width: none; margin: 0; padding: 0; }
            .dice-item { width: auto; flex: 0 0 30%; font-size: min(6vw, 22px); }
            .keep-btn { width: 100%; font-size: 11px; padding: 6px 0; }
        }
    </style>
</head>
<body>
    <div class="game-wrapper">
        <div class="main-area">
            <div class="title">ğŸ² YACHT <span id="room-label" style="font-size:0.4em; color:#fff; opacity:0.8; margin-left:12px;"></span></div>
            <div id="observer-banner" class="observer-banner" style="display:none; background:rgba(255,80,80,0.2); border:1px solid #ff5050; color:#ffaaaa; padding:10px; border-radius:8px; text-align:center; margin-bottom:20px; font-weight:bold;">ğŸ‘ï¸ ê´€ì „ì ëª¨ë“œ: ì‹¤ì‹œê°„ìœ¼ë¡œ ê²Œì„ì„ êµ¬ê²½ ì¤‘ì…ë‹ˆë‹¤.</div>
            <div class="dice-area">
                <div class="dice-grid" id="dice-grid"></div>
                <div class="info-bar">
                    <div id="timer-bar" style="font-size:1.1em; color:#ff6b6b; margin:2px 0 0 0; font-weight:bold; display:none; line-height:2;">â³<span id="timer-count">30</span>ì´ˆ ë‚¨ì•˜ìŠµë‹ˆë‹¤</div>
                    <div class="rolls-remaining">ë‚¨ì€ Roll: <span id="rolls-left">3</span>/3</div>
                    <div id="game-status" style="margin-top: 10px; color: #00ffcc; font-size: 0.9em; text-align: center; min-height: 24px;"></div>
                    <div id="ai-breakdown" class="ai-breakdown"></div>
                    <div id="ai-info-tip" style="margin-top: 8px; padding: 8px 12px; background: rgba(0, 255, 204, 0.1); border-left: 3px solid #00ffcc; border-radius: 5px; font-size: 0.75em; color: #aaa; line-height: 1.4; display: none;">
                        ğŸ’¡ AI ì¶”ì²œ: ê³ ë“ì  ì¡±ë³´(4 of a Kind, Full House, Straight, Yacht) ë‹¬ì„±ì„ ìš°ì„ ìœ¼ë¡œ ê³ ë ¤í•©ë‹ˆë‹¤.<br>ì´ë“¤ì„ ëª¨ë‘ ì™„ì„±í•œ í›„ì—ëŠ” ìƒë‹¨ ì¡±ë³´(Ones~Sixes)ë¥¼ íš¨ìœ¨ì ìœ¼ë¡œ ì±„ìš¸ ìˆ˜ ìˆëŠ” ì¡°í•©ì„ ì œì•ˆí•©ë‹ˆë‹¤.
                    </div>
                </div>
            </div>
            <div class="controls" id="player-controls">
                <button class="btn" onclick="rollDice()" id="roll-btn">ğŸ² ROLL</button>
                <button class="btn" style="background:linear-gradient(135deg, #ff6b6b 0%, #c92a2a 100%); box-shadow:0 4px 15px rgba(255,107,107,0.4);" onclick="leaveRoom()">ğŸšª ë‚˜ê°€ê¸°</button>
            </div>
            <div class="controls" id="observer-controls" style="display:none;">
                <span style="color:#ffd700; font-size:1.1em;">ğŸ‘€ ê´€ì „ì ëª¨ë“œ: ì‹¤ì‹œê°„ìœ¼ë¡œ ê²Œì„ì„ êµ¬ê²½ ì¤‘ì…ë‹ˆë‹¤.</span>
                <button class="btn" style="background:linear-gradient(135deg, #ff6b6b 0%, #c92a2a 100%); box-shadow:0 4px 15px rgba(255,107,107,0.4);" onclick="leaveRoom()">ğŸšª ë‚˜ê°€ê¸°</button>
            </div>
            
            <div class="controls" style="margin-top:10px;" id="multiplayer-controls">
                <button class="btn" style="background:linear-gradient(135deg, #4ecdc4 0%, #44a08d 100%); box-shadow:0 4px 15px rgba(78,205,196,0.4); display:none;" id="pass-turn-btn" onclick="passTurn()">ğŸ” ì„ ê³µê¶Œ ë„˜ê¸°ê¸°</button>
            </div>
        </div>

        <div class="scorecard-area">
            <div id="scorecard"></div>
        </div>
    </div>

    <div id="score-toast" class="toast-overlay"></div>
    <script src="/static/js/yacht_game.js"></script>
    <script>
        // --- [ì „ì—­ ë³€ìˆ˜ ì„¤ì •] ---
        // ë©€í‹°í”Œë ˆì´ ì „ìš©ì´ë¯€ë¡œ ê´€ë ¨ ë³€ìˆ˜ë¥¼ ê°„ì†Œí™”í•©ë‹ˆë‹¤.
        const params = new URLSearchParams(window.location.search);
        let roomCode = params.get('room') || localStorage.getItem('yacht_room') || '';
        
        // ë°© ì •ë³´ê°€ ì—†ìœ¼ë©´ ì¦‰ì‹œ í‡´ì¥
        if (!roomCode) {
            alert('ì˜ëª»ëœ ì ‘ê·¼ì…ë‹ˆë‹¤. ë¡œë¹„ì—ì„œ ë°©ì„ ìƒì„±í•˜ê±°ë‚˜ ì°¸ê°€í•´ì£¼ì„¸ìš”.');
            window.location.href = '/';
        } else {
            localStorage.setItem('yacht_room', roomCode);
        }

        let username = localStorage.getItem('yacht_username') || '';
        var isObserver = false;
        // ê´€ì „ ëª¨ë“œ ì§„ì…: ?mode=observer íŒŒë¼ë¯¸í„°ê°€ ìˆìœ¼ë©´ ê´€ì „ì
        if (params.get('mode') === 'observer') {
            isObserver = true;
            username = username || 'observer_' + Math.floor(Math.random()*10000);
            localStorage.setItem('yacht_username', username);
        }
        if (!username) {
            alert('ë‹‰ë„¤ì„ ì •ë³´ê°€ ì—†ìŠµë‹ˆë‹¤. ë¡œë¹„ì—ì„œ ë‹¤ì‹œ ì…ì¥í•´ì£¼ì„¸ìš”.');
            window.location.href = '/';
        }
                // --- [ê´€ì „ì ì…ì¥ ì²˜ë¦¬] ---
                async function tryObserveRoom() {
                    if (!roomCode || !isObserver) return;
                    try {
                        const res = await fetch(`/api/rooms/${roomCode}/observe`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ username })
                        });
                        if (!res.ok) {
                            alert('ê´€ì „ ì…ì¥ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
                            window.location.href = '/';
                        }
                    } catch (e) {
                        alert('ê´€ì „ ì…ì¥ ì¤‘ ì˜¤ë¥˜ ë°œìƒ.');
                        window.location.href = '/';
                    }
                }
                if (isObserver) {
                    tryObserveRoom();
                }
                // --- [ê´€ì „ì UI ì²˜ë¦¬] ---
                function updateObserverUI() {
                    if (isObserver) {
                        document.getElementById('player-controls').style.display = 'none';
                        document.getElementById('observer-controls').style.display = 'flex';
                        const banner = document.getElementById('observer-banner');
                        if (banner) banner.style.display = 'block';
                    } else {
                        document.getElementById('player-controls').style.display = 'flex';
                        document.getElementById('observer-controls').style.display = 'none';
                        const banner = document.getElementById('observer-banner');
                        if (banner) banner.style.display = 'none';
                    }
                }
                updateObserverUI();
        // --- [ê´€ì „ì ì…ì¥ ì²˜ë¦¬] ---
        async function tryObserveRoom() {
            if (!roomCode || !isObserver) return;
            try {
                const res = await fetch(`/api/rooms/${roomCode}/observe`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ username })
                });
                if (!res.ok) {
                    alert('ê´€ì „ ì…ì¥ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
                    window.location.href = '/';
                }
            } catch (e) {
                alert('ê´€ì „ ì…ì¥ ì¤‘ ì˜¤ë¥˜ ë°œìƒ.');
                window.location.href = '/';
            }
        }
        if (isObserver) {
            tryObserveRoom();
        }

        let roomVersion = 0;
        let syncTimer = null;
        let isApplyingRemote = false;
        let roomPlayers = [];
        let prevPlayerCount = 0;
        let opponentName = '';
        let turnOwner = null;
        let isRolling = false;
        let gameOverToastShown = false;
        let connectionLostHandled = false;
        let syncFailures = 0;

        // í¸ì˜ì„± ë³€ìˆ˜ (ì½ê¸° ì „ìš©)
        let dice, kept, rollsLeft, myCard, oppCard, gameOver, aiRec;
        function updateLocalVars() {
            const state = GameState.getState();
            dice = state.dice;
            kept = state.kept;
            rollsLeft = state.rollsLeft;
            myCard = state.myCard;
            oppCard = state.oppCard;
            gameOver = state.gameOver;
            aiRec = state.aiRec;
        }
        updateLocalVars();

        // --- [íƒ€ì´ë¨¸ ë¡œì§] (ì–‘ìª½ í”Œë ˆì´ì–´ ì‹œê°„ í‘œì‹œ) ---
        function timeOut(){
            const toast = document.getElementById('score-toast');
            toast.innerHTML = `<div class="toast-cat">â° ì‹œê°„ ì´ˆê³¼!</div><div class="toast-score">ìë™ìœ¼ë¡œ ì§„í–‰í•©ë‹ˆë‹¤...</div>`;
            toast.classList.add('show');
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const now = audioContext.currentTime;
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                osc.connect(gain);
                gain.connect(audioContext.destination);
                osc.frequency.value = 1000;
                gain.gain.setValueAtTime(0.3, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                osc.start(now);
                osc.stop(now + 0.15);
            } catch (e) { console.warn('Toast audio failed:', e); }
            setTimeout(() => toast.classList.remove('show'), 1500);
        }

        let timerInterval = null;
        let turnLeftSeconds = null;

        function updateTurnTimer() {
            if (turnLeftSeconds == null || gameOver || rollsLeft === 0) {
                document.getElementById('timer-bar').style.display = 'none';
                return;
            }
            const timerBar = document.getElementById('timer-bar');
            timerBar.style.display = 'block';

            if (isObserver) {
                // [ìˆ˜ì •ë¨] ê´€ì „ìëŠ” ê³ ì •ëœ ìƒëŒ€ ì´ë¦„ì´ ì•„ë‹ˆë¼, ì‹¤ì‹œê°„ 'turnOwner'ë¥¼ í‘œì‹œ
                const currentTurnName = turnOwner || 'í”Œë ˆì´ì–´';
                timerBar.innerHTML = `â³ ${currentTurnName} í„´: <span id="timer-count">${turnLeftSeconds}</span>ì´ˆ`;
                timerBar.style.color = '#ffd700'; 
            } else if (isMyTurn()) {
                // [í”Œë ˆì´ì–´ - ë‚´ í„´]
                timerBar.innerHTML = `â³ <span id="timer-count">${turnLeftSeconds}</span>ì´ˆ ë‚¨ì•˜ìŠµë‹ˆë‹¤`;
                timerBar.style.color = '#ff6b6b'; 
            } else {
                // [í”Œë ˆì´ì–´ - ìƒëŒ€ í„´]
                const oppName = opponentName || 'ìƒëŒ€ë°©';
                timerBar.innerHTML = `â³ ${oppName} í„´: <span id="timer-count">${turnLeftSeconds}</span>ì´ˆ`;
                timerBar.style.color = '#ffd700';
            }
        }

        function startTurnTimer() {
            if (timerInterval) return;

            // ì‹œê°„ ì •ë³´ê°€ ìˆê³  ê²Œì„ ì¤‘ì´ë©´ ë¬´ì¡°ê±´ í‘œì‹œ
            if (turnLeftSeconds != null && !gameOver && rollsLeft > 0) {
                updateTurnTimer();
                timerInterval = setInterval(() => {
                    if (turnLeftSeconds > 0) {
                        turnLeftSeconds--;
                    }
                    updateTurnTimer();
                    
                    if (turnLeftSeconds <= 0 && isMyTurn() && !gameOver && !isRolling) {
                        clearTurnTimer();
                        timeOut();
                        if (rollsLeft > 0) {
                            rollDice();
                        } else {
                            const available = myCard.map((v, i) => v === null ? i : null).filter(v => v !== null);
                            if (available.length > 0) pickCategory(available[0]);
                        }
                    }
                }, 1000);
            } else {
                document.getElementById('timer-bar').style.display = 'none';
            }
        }

        function clearTurnTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            document.getElementById('timer-bar').style.display = 'none';
        }

        function handleConnectionLost(msg = 'ìƒëŒ€ë°©ê³¼ì˜ ì—°ê²°ì´ ëŠì–´ì¡ŒìŠµë‹ˆë‹¤. ë¡œë¹„ë¡œ ì´ë™í•©ë‹ˆë‹¤.') {
            if (connectionLostHandled) return;
            connectionLostHandled = true;
            localStorage.removeItem('yacht_room');
            alert(msg);
            window.location.replace('/');
        }

        window.addEventListener('offline', () => {
            handleConnectionLost('ë„¤íŠ¸ì›Œí¬ ì—°ê²°ì´ ëŠì–´ì¡ŒìŠµë‹ˆë‹¤. ë¡œë¹„ë¡œ ì´ë™í•©ë‹ˆë‹¤.');
        });

        function showGameOverToast(myTotal, oppTotal) {
            if (gameOverToastShown) return;
            const toast = document.getElementById('score-toast');
            let title = 'ğŸ‰ ê²Œì„ ì¢…ë£Œ';
            let detail = `ìµœì¢… ì ìˆ˜: ${myTotal}`;
            
            if (myTotal > oppTotal) title = 'ğŸ† ìŠ¹ë¦¬!';
            else if (myTotal < oppTotal) title = 'ğŸ˜¥ íŒ¨ë°°';
            else title = 'ğŸ¤ ë¬´ìŠ¹ë¶€';
            detail = `ë‚˜ ${myTotal} : ìƒëŒ€ ${oppTotal}`;
            
            toast.innerHTML = `<div class="toast-cat">${title}</div><div class="toast-score">${detail}</div>`;
            toast.classList.add('show');
            playTurnToastSound();
            gameOverToastShown = true;
            setTimeout(() => toast.classList.remove('show'), 2800);
        }

        const isMyTurn = () => {
            if (!turnOwner) return false;
            return turnOwner === username;
        };

        // --- [ì„œë²„ ë™ê¸°í™”] ---
        async function fetchRoomState() {
            if (!roomCode) return Promise.resolve();
            return new Promise((resolve) => {
                fetch(`/api/rooms/${roomCode}?u=${encodeURIComponent(username)}`)
                    .then(async (r) => {
                        if (r.status === 404) {
                            handleConnectionLost();
                            resolve();
                            return;
                        }
                        const data = await r.json();
                        syncFailures = 0;
                        if (data.players) {
                            const prevPlayerCount = roomPlayers.length;
                            roomPlayers = data.players;
                            // ê´€ì „ì ëª¨ë“œì—ì„œëŠ” ê°•ì œ í‡´ì¥ ì—†ìŒ
                            if (!isObserver && !roomPlayers.includes(username)) {
                                handleConnectionLost();
                                resolve();
                                return;
                            }
                            const opp = roomPlayers.find(p => p !== username);
                            if (opp && opp !== opponentName) {
                                opponentName = opp;
                                console.log('ìƒëŒ€ ì…ì¥:', opp);
                            }
                        }
                                // --- [ê´€ì „ì UI ì²˜ë¦¬] ---
                                function updateObserverUI() {
                                    if (isObserver) {
                                        document.getElementById('player-controls').style.display = 'none';
                                        document.getElementById('observer-controls').style.display = 'flex';
                                        // ì¶”ê°€ë¡œ ì ìˆ˜íŒ, ì£¼ì‚¬ìœ„ ë“± í´ë¦­/ì¡°ì‘ ì´ë²¤íŠ¸ ë¹„í™œì„±í™” í•„ìš”ì‹œ êµ¬í˜„
                                    } else {
                                        document.getElementById('player-controls').style.display = 'flex';
                                        document.getElementById('observer-controls').style.display = 'none';
                                    }
                                }
                                updateObserverUI();
                        if (data.state) {
                            turnLeftSeconds = data.state.turn_left_seconds != null ? data.state.turn_left_seconds : null;
                            applyRemoteState(data.state);
                        }
                        resolve();
                    })
                    .catch(e => {
                        console.warn('pull failed', e);
                        syncFailures++;
                        if (syncFailures >= 3) {
                            handleConnectionLost('ì—°ê²° ìƒíƒœë¥¼ í™•ì¸í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ë¡œë¹„ë¡œ ì´ë™í•©ë‹ˆë‹¤.');
                            resolve();
                            return;
                        }
                        resolve();
                    });
            });
        }

        function refreshTurnUI() {
            const statusEl = document.getElementById('game-status');
            if (!statusEl || GameState.isGameOver()) return;

            // íƒ€ì´ë¨¸ ì¼ì‹œì •ì§€ ë¡œì§ì„ ìœ„í•œ ë³€ìˆ˜
            let timerPaused = false; 

            if (isObserver) {
                // [ìˆ˜ì •ë¨] ê´€ì „ì: í˜„ì¬ í„´ ì£¼ì¸ì˜ ì´ë¦„ì„ í‘œì‹œ
                const currentTurnName = turnOwner || 'í”Œë ˆì´ì–´';
                statusEl.innerText = `ğŸ² ${currentTurnName} ë‹˜ì˜ í„´ì…ë‹ˆë‹¤`;
                // ê´€ì „ìëŠ” ì„ ê³µê¶Œ ë„˜ê¸°ê¸° ë²„íŠ¼ ìˆ¨ê¹€
                const passBtn = document.getElementById('pass-turn-btn');
                if(passBtn) passBtn.style.display = 'none';
            } else {
                // [í”Œë ˆì´ì–´] ê¸°ì¡´ ë¡œì§ ìœ ì§€
                if (!opponentName || roomPlayers.length < 2) {
                    statusEl.innerText = 'â³ ìƒëŒ€ë°© ì…ì¥ ëŒ€ê¸° ì¤‘...';
                } else if (!isMyTurn()) {
                    statusEl.innerText = 'â¸ï¸ ìƒëŒ€ í„´ì…ë‹ˆë‹¤';
                } else {
                    statusEl.innerText = 'ğŸ² ì£¼ì‚¬ìœ„ë¥¼ ëŒë ¤ì£¼ì„¸ìš”';
                }

                // ì„ ê³µê¶Œ ë„˜ê¸°ê¸° ë²„íŠ¼ ë¡œì§
                const passBtn = document.getElementById('pass-turn-btn');
                if (passBtn) {
                    const myEmpty = GameState.getMyCard().every(v => v === null);
                    const oppEmpty = GameState.getOppCard().every(v => v === null);
                    if (myEmpty && oppEmpty && rollsLeft === 3 && !gameOver && opponentName && roomPlayers.length >= 2) {
                        timerPaused = true;
                    }
                    const canPass = isMyTurn() && timerPaused;
                    passBtn.style.display = canPass ? 'inline-flex' : 'none';
                }
            }

            updateDice();
            // timerPaused ë³€ìˆ˜ ì ìš©
            if (turnLeftSeconds != null && !gameOver && !timerPaused) {
                startTurnTimer();
            } else {
                clearTurnTimer();
            }
        }

        function updateDice() {
            const transforms = {
                1: 'rotateX(0deg) rotateY(0deg)',
                6: 'rotateX(180deg) rotateY(0deg)',
                2: 'rotateX(-90deg) rotateY(0deg)',
                5: 'rotateX(90deg) rotateY(0deg)',
                3: 'rotateY(-90deg) rotateX(0deg)',
                4: 'rotateY(90deg) rotateX(0deg)'
            };
            
            for (let i = 0; i < 5; i++) {
                const d = document.getElementById(`die-${i}`);
                const c = document.getElementById(`die-container-${i}`);
                if (!d) continue;
                
                if (rollsLeft === 3 && !gameOver) {
                    d.classList.add('rolling');
                } else {
                    d.classList.remove('rolling');
                }

                if (GameState.getKept()[i]) {
                    c.classList.add('locked');
                    d.querySelectorAll('.die-face').forEach(f => f.style.borderColor = '#00ffcc');
                } else {
                    c.classList.remove('locked');
                    d.querySelectorAll('.die-face').forEach(f => f.style.borderColor = 'rgba(200,200,200,0.5)');
                }
                
                const val = GameState.getDice()[i] || 1; 
                d.style.transform = transforms[val];
                
                const keepBtn = document.getElementById(`keep-${i}`);
                const keepText = document.getElementById(`keep-text-${i}`);
                if (keepBtn && keepText) {
                    keepBtn.className = 'keep-btn';
                    
                    if (rollsLeft >= 3 || rollsLeft === 0 || gameOver || isRolling || !isMyTurn()) {
                        keepBtn.disabled = true;
                        keepBtn.style.opacity = '0.5';
                        keepBtn.style.cursor = 'not-allowed';
                    } else {
                        keepBtn.disabled = false;
                        keepBtn.style.opacity = '1';
                        keepBtn.style.cursor = 'pointer';
                    }
                    
                    if (kept[i]) {
                        keepBtn.classList.add('active-keep');
                        keepBtn.style.borderColor = '#00ff00';
                    } else {
                        keepBtn.style.borderColor = 'rgba(255, 255, 255, 0.3)';
                    }

                    let aiInfo = '';
                    keepBtn.style.boxShadow = 'none';

                    if (aiRec?.dice_recommendations) {
                        const r = aiRec.dice_recommendations[i];
                        if (r && r.action === 'keep' && !kept[i]) {
                            keepBtn.style.borderColor = '#00ffcc';
                            keepBtn.style.boxShadow = '0 0 10px rgba(0, 255, 204, 0.8)';
                        }
                    }
                    keepText.innerHTML = (kept[i] ? 'âœ“ KEEP' : 'KEEP') + aiInfo;
                }
                const lbl = document.getElementById(`lock-${i}`);
                if (lbl) lbl.innerText = '';
            }
            document.getElementById('rolls-left').innerText = GameState.getRollsLeft();
            const waitingForOpponent = !opponentName || roomPlayers.length < 2;
            document.getElementById('roll-btn').disabled = GameState.getRollsLeft() <= 0 || GameState.isGameOver() || isRolling || !isMyTurn() || waitingForOpponent;
        }

        function toggleLock(i) {
            if (isObserver || rollsLeft === 3 || gameOver || !isMyTurn()) return;
            kept[i] = kept[i] ? 0 : 1;
            GameState.setKept(kept);
            updateDice();
            pushState();
            playKeepSound();
        }

        function buildStatePayload() {
            const scores = {};
            scores[username] = myCard;
            if (opponentName) scores[opponentName] = oppCard;
            
            return {
                username, dice, kept, rolls_left: rollsLeft, scores,
                turn: turnOwner || username,
                game_over: gameOver,
                ai_rec: aiRec,
            };
        }

        async function pushState() {
            if (!roomCode || !username || isApplyingRemote) return;
            try {
                const r = await fetch(`/api/rooms/${roomCode}/sync`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify(buildStatePayload())
                });
                const data = await r.json();
                if (data.state && typeof data.state.version === 'number') {
                    roomVersion = data.state.version;
                }
            } catch (e) { console.warn('sync failed', e); }
        }

function applyRemoteState(state) {
    if (!state) return;
    if (typeof state.version === 'number' && state.version <= roomVersion) return;
    isApplyingRemote = true;
    roomVersion = state.version || roomVersion;
    
    const prevTurnOwner = turnOwner;
    const playerDice = state.player_dice || {};
    const playerKept = state.player_kept || {};
    const playerRollsLeft = state.player_rolls_left || {};

    // 1. ê´€ì „ì ëª¨ë“œì¼ ë•Œ í”Œë ˆì´ì–´ ì‹ë³„ (ë°©ì¥ vs ì°¸ê°€ì)
    let p1Name = roomPlayers[0]; // ë³´í†µ ë°©ì¥
    let p2Name = roomPlayers[1]; // ì°¸ê°€ì

    // 2. í˜„ì¬ í„´ ì£¼ì¸ì˜ ì£¼ì‚¬ìœ„ ìƒíƒœ ê°€ì ¸ì˜¤ê¸°
    const currentTurnOwner = state.turn;
    const fallbackDice = [1,1,1,1,1];
    const fallbackKept = [0,0,0,0,0];

    let diceToShow = [1,1,1,1,1];
    let keptToShow = [0,0,0,0,0];
    let rollsToShow = 3;

    if (currentTurnOwner && playerDice[currentTurnOwner]) {
        diceToShow = playerDice[currentTurnOwner] || fallbackDice;
        keptToShow = playerKept[currentTurnOwner] || fallbackKept;
        rollsToShow = playerRollsLeft[currentTurnOwner] ?? 3;
    }

    GameState.setDice(diceToShow);
    GameState.setKept(keptToShow);
    GameState.setRollsLeft(rollsToShow);
    GameState.setGameOver(state.game_over ?? GameState.isGameOver());
    
    // 3. í”Œë ˆì´ì–´ ëª©ë¡ ì—…ë°ì´íŠ¸
    const newPlayers = state.players || [];
    roomPlayers = newPlayers;
    
    // ìƒëŒ€ë°© ì´ë¦„ ì—…ë°ì´íŠ¸ (í”Œë ˆì´ì–´ ì…ì¥ì—ì„œ)
    if (!isObserver && !opponentName && roomPlayers.length > 1) {
        const opp = roomPlayers.find(p => p !== username);
        if (opp) opponentName = opp;
    }
    
    if (state.turn) turnOwner = state.turn;
    
    // 4. ì ìˆ˜íŒ ë°ì´í„° ë§¤í•‘ (ê°€ì¥ ì¤‘ìš”í•œ ë¶€ë¶„!)
    const scores = state.scores || {};
    
    if (isObserver) {
        // [ê´€ì „ì ë¡œì§] ë‚˜/ìƒëŒ€ ê°œë… ì—†ì´ P1(ì™¼ìª½), P2(ì˜¤ë¥¸ìª½) ê³ ì •
        p1Name = roomPlayers[0] || 'Player 1';
        p2Name = roomPlayers[1] || 'Player 2';
        
        if (scores[p1Name]) GameState.setMyCard(scores[p1Name]);
        else GameState.setMyCard(Array(12).fill(null));

        if (scores[p2Name]) GameState.setOppCard(scores[p2Name]);
        else GameState.setOppCard(Array(12).fill(null));
        
    } else {
        // [í”Œë ˆì´ì–´ ë¡œì§] ê¸°ì¡´ ìœ ì§€ (ë‚´ ì ìˆ˜ vs ìƒëŒ€ ì ìˆ˜)
        if (scores[username]) GameState.setMyCard(scores[username]);
        
        const guessedOpp = Object.keys(scores).find(n => n !== username) || opponentName;
        if (guessedOpp && scores[guessedOpp]) {
            opponentName = guessedOpp;
            GameState.setOppCard(scores[guessedOpp]);
        }
    }
    
    // 5. AI ì •ë³´ ë° ê¸°íƒ€ UI ì—…ë°ì´íŠ¸
    GameState.setAiRec(state.ai_rec || null);
    updateLocalVars();
    
    // ë‚´ í„´ ì•Œë¦¼ (í”Œë ˆì´ì–´ë§Œ)
    if (!isObserver && prevTurnOwner && prevTurnOwner !== username && turnOwner === username) {
        const toast = document.getElementById('score-toast');
        toast.innerHTML = `<div style="font-size:1.1em; font-weight:bold; color:#00ff00;">âœ¨ ë‹¹ì‹ ì˜ í„´ì…ë‹ˆë‹¤!</div>`;
        toast.classList.add('show');
        playTurnToastSound();
        setTimeout(() => toast.classList.remove('show'), 1500);
    }
    
    // AI Breakdown í‘œì‹œ
    const bd = document.getElementById('ai-breakdown');
    const aiRec = GameState.getAiRec();
    if (aiRec && aiRec.breakdown && aiRec.breakdown.length > 0) {
        bd.innerHTML = aiRec.breakdown.map(item => {
            let color = '#ffd700';
            const barWidth = Math.min(item.prob * 100, 100);
            return `<div class="breakdown-item">
                        <div style="flex:1;">
                            <span style="color:#ccc;">${item.name}</span>
                            <div style="background:rgba(0,0,0,0.3); height:4px; margin-top:4px;">
                                <div style="background:${color}; height:100%; width:${barWidth}%;"></div>
                            </div>
                        </div>
                        <span class="breakdown-val" style="color:${color};">${item.val_str}</span>
                    </div>`;
        }).join('');
    } else {
        bd.innerHTML = '<div style="color:#999; text-align:center;">ëŒ€ê¸° ì¤‘...</div>';
    }

    // ê²Œì„ ì¢…ë£Œ ì²˜ë¦¬
    if (GameState.isGameOver()) {
        const myTotal = calcTotals(GameState.getMyCard()).total;
        const oppTotal = calcTotals(GameState.getOppCard()).total;
        showGameOverToast(myTotal, oppTotal);
    }
    
    refreshTurnUI();
    updateDice();
    updateScorecard(); // ì—¬ê¸°ì„œ ì´ë¦„í‘œ ì—…ë°ì´íŠ¸
    isApplyingRemote = false;
}

        function startSyncPolling() {
            if (syncTimer) return;
            fetchRoomState();
            syncTimer = setInterval(fetchRoomState, 1200);
        }

        async function rollDice() {
            if (rollsLeft <= 0 || gameOver || isRolling || !isMyTurn()) return;
            if (!opponentName || roomPlayers.length < 2) {
                alert('ìƒëŒ€ë°©ì´ ì…ì¥í•  ë•Œê¹Œì§€ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”!');
                return;
            }
            clearTurnTimer();
            
            // Web Audio API íš¨ê³¼ìŒ
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const now = audioContext.currentTime;
                const duration = 0.4;
                const bufferSize = audioContext.sampleRate * duration;
                const noiseBuffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
                const output = noiseBuffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) output[i] = Math.random() * 2 - 1;
                
                const noiseSource = audioContext.createBufferSource();
                noiseSource.buffer = noiseBuffer;
                const noiseGain = audioContext.createGain();
                noiseSource.connect(noiseGain);
                noiseGain.connect(audioContext.destination);
                noiseGain.gain.setValueAtTime(0.2, now);
                noiseGain.gain.exponentialRampToValueAtTime(0.01, now + duration);
                
                const beatDuration = 0.08;
                for (let beat = 0; beat < 5; beat++) {
                    const osc = audioContext.createOscillator();
                    const gain = audioContext.createGain();
                    osc.type = 'square';
                    const freqRange = 1200 - (beat * 160);
                    osc.frequency.value = Math.max(freqRange, 400);
                    osc.connect(gain);
                    gain.connect(audioContext.destination);
                    const startTime = now + (beat * 0.07);
                    gain.gain.setValueAtTime(0.12, startTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, startTime + beatDuration);
                    osc.start(startTime);
                    osc.stop(startTime + beatDuration);
                }
                noiseSource.start(now);
                noiseSource.stop(now + duration);
            } catch (e) { console.warn('Audio context failed:', e); }

            isRolling = true;
            aiRec = null; 
            document.getElementById('ai-breakdown').innerHTML = '<div style="color:#999; text-align:center; padding:12px; font-size:0.9em;">ğŸ² ê³„ì‚° ì¤‘...</div>';
            updateDice(); 

            for (let i = 0; i < 5; i++) {
                if (!kept[i]) document.getElementById(`die-${i}`).classList.add('rolling');
            }
            
            setTimeout(async () => {
                try {
                    // ë©€í‹°í”Œë ˆì´: í•­ìƒ ì„œë²„ì—ì„œ ì£¼ì‚¬ìœ„ êµ´ë¦¼
                    const r = await fetch(`/api/rooms/${roomCode}/roll`, {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({username, kept})
                    });
                    const data = await r.json();
                    if (data.dice && typeof data.rolls_left === 'number') {
                        dice = data.dice;
                        rollsLeft = data.rolls_left;
                        GameState.setDice(dice);
                        GameState.setKept(kept);
                        GameState.setRollsLeft(rollsLeft);
                        turnLeftSeconds = 30;
                    } else {
                        alert('ì£¼ì‚¬ìœ„ êµ´ë¦¼ ì‹¤íŒ¨');
                        isRolling = false;
                        return;
                    }
                    
                    isRolling = false;
                    updateDice();
                    updateScorecard();
                    refreshTurnUI();
                    
                    if (calcScore(dice, 11) === 50) {
                        const toast = document.getElementById('score-toast');
                        if (myCard[11] >= 50) {
                            toast.innerHTML = `<div class="toast-cat">ğŸ† YACHT BONUS ê°€ëŠ¥!</div><div class="toast-score" style="font-size:0.9em;">ë‹¤ë¥¸ ì¹¸ì— ì ìˆ˜ ê¸°ë¡ ì‹œ +100ì </div>`;
                        } else if (myCard[11] === 0) {
                            toast.innerHTML = `<div class="toast-cat" style="color:#ff6b6b;">ğŸ˜¢ YACHT ì„±ê³µì´ì§€ë§Œ</div><div class="toast-score" style="color:#ff6b6b; font-size:0.85em;">Bonus ë¶ˆê°€ëŠ¥ (0ì  ì²˜ë¦¬ë¨)</div>`;
                        } else {
                            toast.innerHTML = `<div class="toast-cat">ğŸ² YACHT ì„±ê³µ!</div><div class="toast-score">50ì </div>`;
                        }
                        toast.classList.add('show');
                        playTurnToastSound();
                        setTimeout(() => toast.classList.remove('show'), 2000);
                    }
                    
                    await askAI();
                    pushState();
                } catch (e) {
                    console.error('Roll failed:', e);
                    isRolling = false;
                }
            }, 600);
        }

        async function askAI() {
            if (gameOver || !isMyTurn()) return;
            try {
                const open_categories = myCard.map((v, i) => v === null ? i : null).filter(v => v !== null);
                const r = await fetch('/api/recommend', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({dice, rolls_left: rollsLeft, scorecard: myCard, open_categories})
                });
                aiRec = await r.json();
                
                const bd = document.getElementById('ai-breakdown');
                if (aiRec.breakdown && aiRec.breakdown.length > 0) {
                    bd.innerHTML = aiRec.breakdown.map(item => {
                        let color = '#ffd700';
                        const barWidth = Math.min(item.prob * 100, 100);
                        return `
                            <div class="breakdown-item">
                                <div style="flex: 1;">
                                    <div style="display:flex; align-items:center; gap:8px; margin-bottom:4px;">
                                        <span style="font-size:1.3em; font-weight:bold; color:${color}">â¤</span>
                                        <span style="color:#ccc; font-weight:500">${item.name}</span>
                                    </div>
                                    <div style="font-size:0.9em; color:#aaa; margin-top:3px; margin-bottom:6px;">${item.keep_str}</div>
                                    <div style="background:rgba(0,0,0,0.3); border-radius:6px; height:6px; margin-right:8px;">
                                        <div style="background:${color}; border-radius:6px; height:100%; width:${barWidth}%; transition:width 0.3s ease;"></div>
                                    </div>
                                </div>
                                <span class="breakdown-val" style="color:${color}; font-weight:bold; min-width:50px; text-align:right">${item.val_str}</span>
                            </div>
                        `;
                    }).join('');
                } else {
                    bd.innerHTML = '<div style="color:#999; text-align:center; padding:12px; font-size:0.9em;">ëŒ€ê¸° ì¤‘...</div>';
                }
                
                updateDice();
            } catch (e) { console.error(e); }
        }

function updateScorecard() {
    const el = document.getElementById('scorecard');
    if (!el) return;

    const safeMyCard = Array.isArray(myCard) ? myCard : Array(12).fill(null);
    const safeOppCard = Array.isArray(oppCard) ? oppCard : Array(12).fill(null);

    if (isObserver) {
        // [ê´€ì „ì ëª¨ë“œ]
        const p1 = (roomPlayers && roomPlayers[0]) ? roomPlayers[0] : 'Player 1';
        const p2 = (roomPlayers && roomPlayers[1]) ? roomPlayers[1] : 'Waiting...';

        // 1. ê¸°ë³¸ ë Œë”ë§ (ì¼ë‹¨ ë‘˜ ë‹¤ ê¸°ë³¸ ìƒ‰ìƒìœ¼ë¡œ ê·¸ë¦¬ê¸°)
        const html1 = renderCard(safeMyCard, false, p1);
        const html2 = renderCard(safeOppCard, false, p2);

        // IDë¥¼ ë¶€ì—¬í•˜ì—¬ ì˜ì—­ì„ í™•ì‹¤íˆ êµ¬ë¶„
        el.innerHTML = `
        <div style="display:flex; gap:16px; flex-wrap:wrap;">
            <div id="p1-card" style="flex:1; min-width:280px;">${html1}</div>
            <div id="p2-card" style="flex:1; min-width:280px;">${html2}</div>
        </div>`;

        // 2. DOM ìš”ì†Œë¥¼ ì§ì ‘ ì°¾ì•„ì„œ ìŠ¤íƒ€ì¼ ë³€ê²½ (ê°€ì¥ ì•ˆì „í•œ ë°©ë²•)
        const p1Title = el.querySelector('#p1-card .scorecard-title');
        const p2Title = el.querySelector('#p2-card .scorecard-title');
        
        // í˜•ê´‘ ì´ˆë¡ ìŠ¤íƒ€ì¼
        const activeStyle = { 
            color: '#00ff00', 
            textShadow: '0 0 20px rgba(0, 255, 0, 0.8)', 
            fontWeight: 'bold' 
        };
        // ê¸°ë³¸ ìŠ¤íƒ€ì¼
        const defaultStyle = { 
            color: '#00ffcc', 
            textShadow: 'none', 
            fontWeight: 'bold' // ì›ë˜ í°íŠ¸ êµµê¸° ìœ ì§€
        };

        // í„´ ì£¼ì¸ì— ë”°ë¼ ìŠ¤íƒ€ì¼ ì ìš©
        if (p1Title) Object.assign(p1Title.style, (turnOwner === p1) ? activeStyle : defaultStyle);
        if (p2Title) Object.assign(p2Title.style, (turnOwner === p2) ? activeStyle : defaultStyle);

    } else {
        // [í”Œë ˆì´ì–´ ëª¨ë“œ] - ê¸°ì¡´ ìœ ì§€
        const oppLabel = opponentName || 'ìƒëŒ€ ëŒ€ê¸° ì¤‘';
        // ë””ë²„ê¹…: rollsLeft, dice, isMyTurn()
        console.log('[updateScorecard] rollsLeft:', rollsLeft, 'dice:', dice, 'isMyTurn:', (typeof isMyTurn === 'function' ? isMyTurn() : isMyTurn));
        el.innerHTML = `
        <div style="display:flex; gap:16px; flex-wrap:wrap;">
            <div style="flex:1; min-width:280px;">${renderCard(myCard, true, 'ë‚˜ (' + username + ')')}</div>
            <div style="flex:1; min-width:280px;">${renderCard(oppCard, false, 'ìƒëŒ€ (' + oppLabel + ')')}</div>
        </div>`;
    }
}

// ê²Œì„ ì¤‘(ê²Œì„ì˜¤ë²„ ì „)ì— í˜ì´ì§€ë¥¼ ë– ë‚˜ë ¤ í•  ë•Œ ê²½ê³ ì°½ ë„ìš°ê¸°
window.addEventListener('beforeunload', (e) => {
    // ê´€ì „ìê±°ë‚˜ ê²Œì„ì´ ëë‚¬ìœ¼ë©´ ê²½ê³  ì—†ì´ ì´ë™
    if (isObserver || gameOver) return;
    
    // í‘œì¤€ ë°©ì‹: ì‚¬ìš©ìì—ê²Œ í™•ì¸ ë©”ì‹œì§€ ìœ ë„
    e.preventDefault();
    e.returnValue = '';
});

        function showToast(category, score) {
            const toast = document.getElementById('score-toast');
            toast.innerHTML = `<div class="toast-cat">${category}</div><div class="toast-score">+${score}</div>`;
            toast.classList.add('show');
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const now = audioContext.currentTime;
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                osc.connect(gain);
                gain.connect(audioContext.destination);
                osc.frequency.value = 1000;
                gain.gain.setValueAtTime(0.3, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                osc.start(now);
                osc.stop(now + 0.15);
            } catch (e) { console.warn('Toast audio failed:', e); }
            setTimeout(() => toast.classList.remove('show'), 1500);
        }

        function pickCategory(i) {
            if (!isMyTurn() || myCard[i] !== null || rollsLeft === 3 || gameOver) return;
            clearTurnTimer(); 
            let score = calcScore(dice, i);
            
            let yachtBonus = 0;
            if (calcScore(dice, 11) === 50 && myCard[11] >= 50 && i !== 11 && score > 0) {
                yachtBonus = 100;
                myCard[11] += yachtBonus;
            }
            
            myCard[i] = score;
            if (yachtBonus > 0) {
                showToast(`ğŸ† Yacht Bonus: ${CATS[i]} +${score}ì , Yacht +100ì `, score);
            } else {
                showToast(CATS[i], score);
            }
            
            dice = [1,1,1,1,1];
            kept = [0,0,0,0,0];
            rollsLeft = 3;
            turnLeftSeconds = 30;
            aiRec = null;

            if (opponentName) turnOwner = opponentName;

            const myDone = myCard.every(v => v !== null);
            const oppDone = opponentName ? oppCard.every(v => v !== null) : true;
            if (myDone && oppDone) {
                gameOver = true;
                const myTotal = calcTotals(myCard).total;
                const oppTotal = calcTotals(oppCard).total;
                const statusEl = document.getElementById('game-status');
                if (statusEl) statusEl.innerText = `ğŸ‰ ê²Œì„ ì¢…ë£Œ! ë‚˜ ${myTotal} : ìƒëŒ€ ${oppTotal}`;

                showGameOverToast(myTotal, oppTotal);

                if (username) {
                    const p2 = opponentName || null;
                    saveGameResult(username, myTotal, p2, oppTotal || 0);
                }
            }

            GameState.setState({
                dice: [...dice],
                kept: [...kept],
                rollsLeft,
                myCard: [...myCard],
                oppCard: [...oppCard],
                gameOver,
                aiRec,
            });

            updateDice();
            updateScorecard();
            refreshTurnUI();
            pushState();
        }

        function saveGameResult(username, finalScore, player2 = null, score2 = 0) {
            fetch('/api/save-game', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({
                    player1: username,
                    score1: finalScore,
                    player2,
                    score2
                })
            })
            .then(r => r.json())
            .then(data => {
                if (data.status === 'success') {
                    setTimeout(() => {
                        alert(`ê²Œì„ ì¢…ë£Œ!\n\nìµœì¢… ì ìˆ˜: ${finalScore}ì \n\në¡œë¹„ë¡œ ì´ë™í•©ë‹ˆë‹¤.`);
                        window.location.replace('/');
                    }, 800);
                }
            })
            .catch(e => console.error('Failed to save game:', e));
        }

        async function leaveRoom() {
            if (!confirm('ì •ë§ ë‚˜ê°€ì‹œê² ìŠµë‹ˆê¹Œ?')) return;
            try {
                const payload = JSON.stringify({username});
                if (navigator.sendBeacon) {
                    const url = `/api/rooms/${roomCode}/leave?username=${encodeURIComponent(username)}`;
                    navigator.sendBeacon(url, payload);
                } else {
                    fetch(`/api/rooms/${roomCode}/leave`, {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: payload,
                        keepalive: true,
                        cache: 'no-store',
                    }).catch((e) => console.warn('leave failed (non-blocking)', e));
                }
                localStorage.removeItem('yacht_room');
                gameOverToastShown = true;
                alert('ë¡œë¹„ë¡œ ì´ë™í•©ë‹ˆë‹¤');
            } catch (e) {
                console.error('Leave failed', e);
                alert('ë‚˜ê°€ê¸° ì‹¤íŒ¨');
                return;
            }
            window.location.replace('/');
        }

        function passTurn() {
            const myEmpty = GameState.getMyCard().every(v => v === null);
            const oppEmpty = GameState.getOppCard().every(v => v === null);
            if (!opponentName || !isMyTurn() || GameState.getRollsLeft() !== 3 || !myEmpty || !oppEmpty) return;
            
            turnOwner = opponentName;
            refreshTurnUI();
            updateDice();
            updateScorecard();
            pushState();
            
            const toast = document.getElementById('score-toast');
            toast.innerHTML = `<div style="font-size:0.8em;">ì„ ê³µê¶Œì„ ${opponentName}ë‹˜ì—ê²Œ ë„˜ê²¼ìŠµë‹ˆë‹¤</div>`;
            toast.classList.add('show');
            playTurnToastSound();
            setTimeout(() => toast.classList.remove('show'), 2000);
        }

        async function initializeGame() {
            renderDice();
            updateScorecard();
            document.getElementById('ai-breakdown').innerHTML = '<div style="color:#999; text-align:center; padding:12px; font-size:0.9em;">ğŸ² ì£¼ì‚¬ìœ„ë¥¼ êµ´ë ¤ì£¼ì„¸ìš”</div>';
            const roomLabel = document.getElementById('room-label');
            if (roomLabel) roomLabel.textContent = `Room ${roomCode}`;
            
            try {
                await fetchRoomState(); 
            } catch (e) {
                console.warn('Failed to fetch initial room state:', e);
            }
            startSyncPolling(); 
            refreshTurnUI();
        }

        initializeGame().catch(e => console.error('Initialization error:', e));
    </script>
</body>
</html>